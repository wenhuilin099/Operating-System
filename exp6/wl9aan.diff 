diff --git a/exp6/build/boot_s.o b/exp6/build/boot_s.o
index 6abdc69..33bfe5f 100644
Binary files a/exp6/build/boot_s.o and b/exp6/build/boot_s.o differ
diff --git a/exp6/build/entry_s.o b/exp6/build/entry_s.o
index 668c76b..43e7482 100644
Binary files a/exp6/build/entry_s.o and b/exp6/build/entry_s.o differ
diff --git a/exp6/build/fork_c.o b/exp6/build/fork_c.o
index 861c0f5..34ccd15 100644
Binary files a/exp6/build/fork_c.o and b/exp6/build/fork_c.o differ
diff --git a/exp6/build/irq_c.o b/exp6/build/irq_c.o
index e314834..a04f47f 100644
Binary files a/exp6/build/irq_c.o and b/exp6/build/irq_c.o differ
diff --git a/exp6/build/irq_s.o b/exp6/build/irq_s.o
index 48b9096..8d49e16 100644
Binary files a/exp6/build/irq_s.o and b/exp6/build/irq_s.o differ
diff --git a/exp6/build/kernel8.elf b/exp6/build/kernel8.elf
index 76d12ad..24b61ab 100755
Binary files a/exp6/build/kernel8.elf and b/exp6/build/kernel8.elf differ
diff --git a/exp6/build/kernel_c.o b/exp6/build/kernel_c.o
index f7c1f0e..5a2aff9 100644
Binary files a/exp6/build/kernel_c.o and b/exp6/build/kernel_c.o differ
diff --git a/exp6/build/mini_uart_c.o b/exp6/build/mini_uart_c.o
index 03eb464..baabb5f 100644
Binary files a/exp6/build/mini_uart_c.o and b/exp6/build/mini_uart_c.o differ
diff --git a/exp6/build/mm_c.o b/exp6/build/mm_c.o
index 91ecdff..75ad32a 100644
Binary files a/exp6/build/mm_c.o and b/exp6/build/mm_c.o differ
diff --git a/exp6/build/mm_s.o b/exp6/build/mm_s.o
index 75a1331..9158d2c 100644
Binary files a/exp6/build/mm_s.o and b/exp6/build/mm_s.o differ
diff --git a/exp6/build/printf_c.o b/exp6/build/printf_c.o
index dd765eb..39a82d3 100644
Binary files a/exp6/build/printf_c.o and b/exp6/build/printf_c.o differ
diff --git a/exp6/build/sched_c.o b/exp6/build/sched_c.o
index 6a4664a..d92259a 100644
Binary files a/exp6/build/sched_c.o and b/exp6/build/sched_c.o differ
diff --git a/exp6/build/sched_s.o b/exp6/build/sched_s.o
index b015dda..c8568ef 100644
Binary files a/exp6/build/sched_s.o and b/exp6/build/sched_s.o differ
diff --git a/exp6/build/sys_c.o b/exp6/build/sys_c.o
index d6f0082..6414a58 100644
Binary files a/exp6/build/sys_c.o and b/exp6/build/sys_c.o differ
diff --git a/exp6/build/timer_c.d b/exp6/build/timer_c.d
index 78560b5..529d070 100644
--- a/exp6/build/timer_c.d
+++ b/exp6/build/timer_c.d
@@ -1,3 +1,3 @@
 build/timer_c.o: src/timer.c include/utils.h include/printf.h \
  include/sched.h include/peripherals/timer.h include/peripherals/base.h \
- include/mm.h include/peripherals/base.h include/sched.h
+ include/mm.h include/peripherals/base.h include/sched.h include/timer.h
diff --git a/exp6/build/timer_c.o b/exp6/build/timer_c.o
index fb145e9..2c0c4a2 100644
Binary files a/exp6/build/timer_c.o and b/exp6/build/timer_c.o differ
diff --git a/exp6/build/timer_s.o b/exp6/build/timer_s.o
index abd62fe..dfd4e05 100644
Binary files a/exp6/build/timer_s.o and b/exp6/build/timer_s.o differ
diff --git a/exp6/build/user_c.o b/exp6/build/user_c.o
index fccfde5..77028fb 100644
Binary files a/exp6/build/user_c.o and b/exp6/build/user_c.o differ
diff --git a/exp6/build/user_sys_s.o b/exp6/build/user_sys_s.o
index 0734af1..30d2509 100644
Binary files a/exp6/build/user_sys_s.o and b/exp6/build/user_sys_s.o differ
diff --git a/exp6/build/utils_s.o b/exp6/build/utils_s.o
index b839379..debff4d 100644
Binary files a/exp6/build/utils_s.o and b/exp6/build/utils_s.o differ
diff --git a/exp6/include/peripherals/irq.h b/exp6/include/peripherals/irq.h
index 58c8c70..3c3059a 100644
--- a/exp6/include/peripherals/irq.h
+++ b/exp6/include/peripherals/irq.h
@@ -22,7 +22,7 @@
 // See BCM2836 ARM-local peripherals at
 // https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2836/QA7_rev3.4.pdf
 
-#define TIMER_INT_CTRL_0    (0x40000040)
+#define TIMER_INT_CTRL_0    (VA_START+0x40000040)
 #define INT_SOURCE_0        (LPBASE+0x60)
 
 #define TIMER_INT_CTRL_0_VALUE  (1 << 1)
diff --git a/exp6/kernel8.img b/exp6/kernel8.img
index 37bfdc2..79c81f5 100755
Binary files a/exp6/kernel8.img and b/exp6/kernel8.img differ
diff --git a/exp6/src/boot.S b/exp6/src/boot.S
index 909bf65..69cadf5 100644
--- a/exp6/src/boot.S
+++ b/exp6/src/boot.S
@@ -115,6 +115,7 @@ el1_entry:
 	// @tbl now points to the newly created PUD table
 	create_table_entry \tbl, \virt, PUD_SHIFT, \tmp1, \tmp2		// set a PUD entry
 	// @tbl now points to the newly created PMD table
+	create_table_entry2 \tbl, \virt, PGD_SHIFT, \tmp1, \tmp2
 	.endm
 
 	// Allocating a new page table (either PGD or PUD) for the kernel's initial page tables
@@ -135,6 +136,18 @@ el1_entry:
 	add	\tbl, \tbl, #PAGE_SIZE					// point @tbl to the newly create next level pgtable. programming ease
 	.endm
 
+	.macro  create_table_entry2, tbl, virt, shift, tmp1, tmp2
+        lsr     \tmp1, \virt, #\shift
+        and     \tmp1, \tmp1, #PTRS_PER_TABLE - 1              // tmp1: table index
+        add     \tmp2, \tbl, #PAGE_SIZE                                 // tmp2: addr of a next level pgtable (PUD or PMD). 
+        add	\tmp2, \tmp2, #SECTION_SIZE
+	orr     \tmp2, \tmp2, #MM_TYPE_PAGE_TABLE               // tmp2: make a table descriptor. set bits[0:1] to 1. 
+        str     \tmp2, [\tbl, \tmp1, lsl #3]                    // store descriptor (tmp2) to the current pgtable at index (tmp1)
+        add     \tbl, \tbl, #PAGE_SIZE                                  // point @tbl to the newly create next level pgtable. programming ease
+        add	\tbl, \tbl, #SECTION_SIZE
+	.endm
+
+
 	// Populating entries in a PMD table for a given virt addr range 
 	// @tbl: a reg pointing to the PMD table
 	// @phys: the start of the physical region to be mapped
@@ -196,6 +209,11 @@ __create_page_tables:
 	ldr		x3, =(VA_START + DEVICE_BASE - SECTION_SIZE)  // x3 = the virtual base of the last section
 	create_block_map x0, x1, x2, x3, MMU_FLAGS, x4
 
+	mov	x1, #PHYS_MEMORY_SIZE
+	ldr	x2, =(VA_START + PHYS_MEMORY_SIZE)
+	ldr	x3, =(VA_START + PHYS_MEMORY_SIZE + SECTION_SIZE)
+	create_block_map x6, x1, x2, x3, MMU_DEVICE_FLAGS, x4
+
 	/* Mapping device memory. Phys addr range: DEVICE_BASE--PHYS_MEMORY_SIZE(0x40000000) */
 	mov 	x1, #DEVICE_BASE					// x1 = start mapping from device base address 
 	ldr 	x2, =(VA_START + DEVICE_BASE)				// x2 = first virtual address
diff --git a/exp6/src/boot.S.save b/exp6/src/boot.S.save
new file mode 100644
index 0000000..ccc6363
--- /dev/null
+++ b/exp6/src/boot.S.save
@@ -0,0 +1,208 @@
+#include "arm/mmu.h"
+#include "arm/sysregs.h"
+#include "mm.h"
+#include "peripherals/base.h"
+
+.section ".text.boot"
+
+.globl _start
+_start:
+	mrs	x0, mpidr_el1		
+	and	x0, x0,#0xFF		// Check processor id
+	cbz	x0, master		// Hang for all non-primary CPU
+	b	proc_hang
+
+proc_hang: 
+	b proc_hang
+
+master:
+	ldr	x0, =SCTLR_VALUE_MMU_DISABLED
+	msr	sctlr_el1, x0		
+	
+	mrs x0, CurrentEL
+  lsr x0, x0, #2
+	cmp x0, #3
+	beq el3
+
+//	ldr	x0, =HCR_VALUE
+//	msr	hcr_el2, x0
+	mrs	x0, hcr_el2
+	orr	x0, x0, #(1<<31)
+	msr	hcr_el2, x0
+
+	mov 	x0, #SPSR_VALUE
+	msr	spsr_el2, x0
+
+	adr	x0, el1_entry
+	msr	elr_el2, x0
+	eret
+
+el3:
+  ldr x0, =HCR_VALUE
+  msr hcr_el2, x0
+
+	ldr	x0, =SCR_VALUE
+	msr	scr_el3, x0
+
+	ldr	x0, =SPSR_VALUE
+	msr	spsr_el3, x0
+
+	adr	x0, el1_entry		
+	msr	elr_el3, x0
+
+	eret				
+
+el1_entry:
+	adr	x0, bss_begin
+	adr	x1, bss_end
+	sub	x1, x1, x0
+	bl 	memzero
+
+#ifdef USE_QEMU
+// A workaround for QEMU's quirks on MMU emulation, which also showcases how __create_page_tables
+// can be used. 
+// 
+// As soon as the MMU is on and CPU switches from physical addresses to virtual addresses, 
+// the emulated CPU seems to be still fetching next (few) instructions using the physical 
+// addresses of those instructions. These addresses will go through MMU for translation 
+// as if they are virtual addresses. Of course our kernel pgtables do not have translation
+// for these addresses (TTBR1 is for translating virtual addresses at 0xffff...). That causes 
+// MMU to throw a Prefetch abort. (prefetch == instruction loading)
+//
+// Real Rpi3 hardware has no such a problem: after MMU is on, it will not fetch instructions 
+// at addresses calculated before MMU is on. 
+//
+// The workaround is to set an "identity" mapping. That is, we create an additional 
+// pgtable tree at TTBR0 that maps all physical DRAM (0 -- PHYS_MEMORY_SIZE) to virtual 
+// addresses with the same values. That keeps translation going on at the switch of MMU. 
+//
+// Cf: https://github.com/s-matyukevich/raspberry-pi-os/issues/8
+// https://www.raspberrypi.org/forums/viewtopic.php?t=222408
+	bl	__create_idmap
+	adrp	x0, idmap_dir
+	msr	ttbr0_el1, x0
+#endif
+
+	bl 	__create_page_tables
+
+	mov	x0, #VA_START			
+	add	sp, x0, #LOW_MEMORY
+
+	adrp	x0, pg_dir				
+	msr	ttbr1_el1, x0
+
+	// tcr_el1: Translation Control Register, responsible for configuring MMU, e.g. page size
+	ldr	x0, =(TCR_VALUE)		
+	msr	tcr_el1, x0 
+
+	ldr	x0, =(MAIR_VALUE)
+	msr	mair_el1, x0
+
+	ldr	x2, =kernel_main
+
+	mov	x0, #SCTLR_MMU_ENABLED				
+	msr	sctlr_el1, x0	// BOOM! we are on virtual after this.
+
+	br 	x2
+
+	// Given a virt addr and the PGD, set the PGD entry, allocate one PUD and one PMD.
+	//		link PGD -> PUD and PUD -> PMD
+	// @tbl: a register pointing to PGD
+	// @virt: the virtual address that we are currently mapping
+	// @tmp1/2: temporary registers to use; contents will be clobbered 
+	.macro	create_pgd_entry, tbl, virt, tmp1, tmp2
+	create_table_entry \tbl, \virt, PGD_SHIFT, \tmp1, \tmp2  // set a PGD entry
+	// @tbl now points to the newly created PUD table
+	create_table_entry \tbl, \virt, PUD_SHIFT, \tmp1, \tmp2		// set a PUD entry
+	// @tbl now points to the newly created PMD table
+
+	.endm
+
+	// Allocating a new page table (either PGD or PUD) for the kernel's initial page tables
+	// All the initial page tables are located in one continuous memory region
+	//
+	// @tbl: a register pointing to the last pgtable in a memory region, from which pgtables 
+	//			are allocated sequentially
+	// @virt: the virtual address that we are currently mapping
+	// @shift: 39 in case of PGD and 30 in case of PUD
+	// 		   apply to the virtual address in order to extract current table index. 
+	// @tmp1/2: temporary registers to use; contents will be clobbered 
+	.macro	create_table_entry, tbl, virt, shift, tmp1, tmp2
+	lsr	\tmp1, \virt, #\shift
+	and	\tmp1, \tmp1, #PTRS_PER_TABLE - 1		// tmp1: table index
+	add	\tmp2, \tbl, #PAGE_SIZE					// tmp2: addr of a next level pgtable (PUD or PMD). 
+	orr	\tmp2, \tmp2, #MM_TYPE_PAGE_TABLE		// tmp2: make a table descriptor. set bits[0:1] to 1. 
+	str	\tmp2, [\tbl, \tmp1, lsl #3]			// store descriptor (tmp2) to the current pgtable at index (tmp1)
+	add	\tbl, \tbl, #PAGE_SIZE					// point @tbl to the newly create next level pgtable. programming ease
+	.endm
+
+	// Populating entries in a PMD table for a given virt addr range 
+	// @tbl: a reg pointing to the PMD table
+	// @phys: the start of the physical region to be mapped
+	// @start/@end: virtual address of the first/last section to be mapped
+	// @flags: to be copied into lower attributes of the block descriptor
+	// @tmp1: temporary register to use; contents will be clobbered
+	.macro	create_block_map, tbl, phys, start, end, flags, tmp1
+	lsr	\start, \start, #SECTION_SHIFT
+	and	\start, \start, #PTRS_PER_TABLE - 1			// start index in the PMD
+	lsr	\end, \end, #SECTION_SHIFT
+	and	\end, \end, #PTRS_PER_TABLE - 1				// end index in the PMD
+	lsr	\phys, \phys, #SECTION_SHIFT				// assmble a table entry 
+	mov	\tmp1, #\flags
+	orr	\phys, \tmp1, \phys, lsl #SECTION_SHIFT			// phys: the table entry value
+9999:	str	\phys, [\tbl, \start, lsl #3]				// store the entry in PMD
+	add	\start, \start, #1								// @start: index of next PMD entry 
+	add	\phys, \phys, #SECTION_SIZE						// update the table entry value
+	cmp	\start, \end
+	b.ls	9999b
+	.endm
+
+#ifdef USE_QEMU
+__create_idmap:
+	mov	x29, x30
+	
+	adrp	x0, idmap_dir
+	mov	x1, #PG_DIR_SIZE
+	bl	memzero
+
+	adrp	x0, idmap_dir
+	mov	x1, xzr
+	create_pgd_entry	x0, x1, x2, x3
+
+	mov	x1, xzr
+	mov	x2, xzr
+	ldr	x3, =(PHYS_MEMORY_SIZE)
+	create_block_map x0, x1, x2, x3, MMU_FLAGS, x4
+
+	mov	x30, x29
+	ret
+#endif
+
+__create_page_tables:
+	mov		x29, x30						// save return address
+
+	// clear the mem region backing pgtables
+	adrp 	x0, pg_dir
+	mov		x1, #PG_DIR_SIZE
+	bl 		memzero
+
+	// allocate one PUD & one PMD; link PGD (pg_dir)->PUD, and PUD->PMD
+	adrp	x0, pg_dir
+	mov		x1, #VA_START 
+	create_pgd_entry x0, x1, x2, x3		// after this, x0 points to the new PMD table
+
+	/* Mapping kernel and init stack. Phys addr range: 0--DEVICE_BASE */
+	mov 	x1, xzr				// x1 = starting phys addr. set x1 to 0. 
+	mov 	x2, #VA_START		// x2 = the virtual base of the first section
+	ldr		x3, =(VA_START + DEVICE_BASE - SECTION_SIZE)  // x3 = the virtual base of the last section
+	create_block_map x0, x1, x2, x3, MMU_FLAGS, x4
+
+	/* Mapping device memory. Phys addr range: DEVICE_BASE--PHYS_MEMORY_SIZE(0x40000000) */
+	mov 	x1, #DEVICE_BASE					// x1 = start mapping from device base address 
+	ldr 	x2, =(VA_START + DEVICE_BASE)				// x2 = first virtual address
+	ldr		x3, =(VA_START + PHYS_MEMORY_SIZE - SECTION_SIZE)	// x3 = the virtual base of the last section
+	create_block_map x0, x1, x2, x3, MMU_DEVICE_FLAGS, x4
+
+	mov	x30, x29						// restore return address
+	ret
+
diff --git a/exp6/src/irq.c b/exp6/src/irq.c
index cbf2531..22d396d 100644
--- a/exp6/src/irq.c
+++ b/exp6/src/irq.c
@@ -31,7 +31,7 @@ void enable_interrupt_controller()
 	put32(ENABLE_IRQS_1, SYSTEM_TIMER_IRQ_1);
 
   // Enables Core 0 Timers interrupt control for the generic timer
-//  put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
+	put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
 }
 
 void show_invalid_entry_message(int type, unsigned long esr, unsigned long address)
diff --git a/exp6/src/timer.c b/exp6/src/timer.c
index bdf4efd..80cf46a 100644
--- a/exp6/src/timer.c
+++ b/exp6/src/timer.c
@@ -2,7 +2,7 @@
 #include "printf.h"
 #include "sched.h"
 #include "peripherals/timer.h"
-
+#include "timer.h"
 const unsigned int interval = 200000;
 unsigned int curVal = 0;
 
@@ -34,15 +34,15 @@ void handle_timer_irq( void )
 	They are fully functional on both QEMU and Rpi3 
 */
 
-//void generic_timer_init ( void )
-//{
-//	gen_timer_init();
-//	gen_timer_reset();
-//}
-//
-//void handle_generic_timer_irq( void )
-//{
-//	gen_timer_reset();
-//	timer_tick();
-//}
+void generic_timer_init ( void )
+{
+	gen_timer_init();
+	gen_timer_reset();
+}
+
+void handle_generic_timer_irq( void )
+{
+	gen_timer_reset();
+	timer_tick();
+}
 
diff --git a/wl9aa.diff b/wl9aa.diff
index e2f467c..e69de29 100644
--- a/wl9aa.diff
+++ b/wl9aa.diff
@@ -1,4426 +0,0 @@
-diff --git a/src/exp4a/include/sched.h b/src/exp4a/include/sched.h
-index ed9e94c..7c61b11 100644
---- a/src/exp4a/include/sched.h
-+++ b/src/exp4a/include/sched.h
-@@ -9,17 +9,14 @@
- 
- #define NR_TASKS				64 
- 
--
- #define FIRST_TASK task[0]
- #define LAST_TASK task[NR_TASKS-1]
- 
- #define TASK_RUNNING				0
--#define TASK_WAITING				1
- 
- extern struct task_struct *current;
- extern struct task_struct * task[NR_TASKS];
- extern int nr_tasks;
--//extern int delay_sec;
- 
- struct cpu_context {
- 	unsigned long x19;
-@@ -42,7 +39,6 @@ struct task_struct {
- 	long state;	
- 	long counter;
- 	long priority;
--	long delay_sec;
- 	long preempt_count;
- };
- 
-@@ -53,11 +49,10 @@ extern void schedule(void);
- //extern void preempt_enable(void);
- extern void switch_to(struct task_struct* next);
- extern void cpu_switch_to(struct task_struct* prev, struct task_struct* next);
--//extern void sleep(void)
- 
- #define INIT_TASK \
- /*cpu_context*/	{ {0,0,0,0,0,0,0,0,0,0,0,0,0}, \
--/* state etc */	0,0,1,0, 0 \
-+/* state etc */	0,0,1, 0 \
- }
- 
- #endif
-diff --git a/src/exp4a/include/sched.h.save b/src/exp4a/include/sched.h.save
-deleted file mode 100644
-index f18f990..0000000
---- a/src/exp4a/include/sched.h.save
-+++ /dev/null
-@@ -1,62 +0,0 @@
--ifndef _SCHED_H
--#define _SCHED_H
--
--#define THREAD_CPU_CONTEXT			0 		// offset of cpu_context in task_struct 
--
--#ifndef __ASSEMBLER__
--
--#define THREAD_SIZE				4096
--
--#define NR_TASKS				64 
--
--//#define delay_sec
--#define FIRST_TASK task[0]
--#define LAST_TASK task[NR_TASKS-1]
--
--#define TASK_RUNNING				0
--#define TASK_WAITING				0
--
--extern struct task_struct *current;
--extern struct task_struct * task[NR_TASKS];
--extern int nr_tasks;
--
--struct cpu_context {
--	unsigned long x19;
--	unsigned long x20;
--	unsigned long x21;
--	unsigned long x22;
--	unsigned long x23;
--	unsigned long x24;
--	unsigned long x25;
--	unsigned long x26;
--	unsigned long x27;
--	unsigned long x28;
--	unsigned long fp;
--	unsigned long sp;
--	unsigned long pc;
--};
--
--struct task_struct {
--	struct cpu_context cpu_context;
--	long state;	
--	long counter;
--	long priority;
--	long preempt_count;
--};
--
--extern void sched_init(void);
--extern void schedule(void);
--//extern void timer_tick(void);
--//extern void preempt_disable(void);
--//extern void preempt_enable(void);
--extern void switch_to(struct task_struct* next);
--extern void cpu_switch_to(struct task_struct* prev, struct task_struct* next);
--//extern void sleep(void)
--
--#define INIT_TASK \
--/*cpu_context*/	{ {0,0,0,0,0,0,0,0,0,0,0,0,0}, \
--/* state etc */	0,0,1, 0 \
--}
--
--#endif
--#endif
-diff --git a/src/exp4a/result.log b/src/exp4a/result.log
-deleted file mode 100644
-index 7b5a63f..0000000
---- a/src/exp4a/result.log
-+++ /dev/null
-@@ -1,3897 +0,0 @@
--
--build/kernel8.elf:     file format elf64-littleaarch64
--
--
--Disassembly of section .text.boot:
--
--0000000000080000 <_start>:
--
--.section ".text.boot"
--
--.globl _start
--_start:
--	mrs	x0, mpidr_el1		
--   80000:	d53800a0 	mrs	x0, mpidr_el1
--	and	x0, x0,#0xFF		// Check processor id
--   80004:	92401c00 	and	x0, x0, #0xff
--	cbz	x0, master		// Hang for all non-primary CPU
--   80008:	b4000060 	cbz	x0, 80014 <master>
--	b	proc_hang
--   8000c:	14000001 	b	80010 <proc_hang>
--
--0000000000080010 <proc_hang>:
--
--proc_hang: 
--	b 	proc_hang
--   80010:	14000000 	b	80010 <proc_hang>
--
--0000000000080014 <master>:
--
--master:
--	ldr	x0, =SCTLR_VALUE_MMU_DISABLED // System control register
--   80014:	58000220 	ldr	x0, 80058 <el1_entry+0x20>
--	msr	sctlr_el1, x0		
--   80018:	d5181000 	msr	sctlr_el1, x0
--
--	ldr	x0, =HCR_VALUE  	// Hypervisor Configuration (EL2) 
--   8001c:	58000220 	ldr	x0, 80060 <el1_entry+0x28>
--	msr	hcr_el2, x0  
--   80020:	d51c1100 	msr	hcr_el2, x0
--
--#ifdef USE_QEMU 		// xzl: qemu boots from EL2. cannot do things to EL3			
--	ldr	x0, =SPSR_VALUE	
--   80024:	58000220 	ldr	x0, 80068 <el1_entry+0x30>
--	msr	spsr_el2, x0
--   80028:	d51c4000 	msr	spsr_el2, x0
--
--	adr	x0, el1_entry		
--   8002c:	10000060 	adr	x0, 80038 <el1_entry>
--	msr	elr_el2, x0
--   80030:	d51c4020 	msr	elr_el2, x0
--
--	adr	x0, el1_entry		
--	msr	elr_el3, x0
--#endif
--  
--	eret				
--   80034:	d69f03e0 	eret
--
--0000000000080038 <el1_entry>:
--
--el1_entry:
--	adr	x0, bss_begin
--   80038:	1001adc0 	adr	x0, 835f0 <lfb>
--	adr	x1, bss_end
--   8003c:	104073a1 	adr	x1, 100eb0 <bss_end>
--	sub	x1, x1, x0
--   80040:	cb000021 	sub	x1, x1, x0
--	bl 	memzero
--   80044:	94000d49 	bl	83568 <memzero>
--
--	mov	sp, #LOW_MEMORY
--   80048:	b26a03ff 	mov	sp, #0x400000              	// #4194304
--	bl	kernel_main
--   8004c:	940004b6 	bl	81324 <kernel_main>
--	b 	proc_hang		// should never come here
--   80050:	17fffff0 	b	80010 <proc_hang>
--   80054:	00000000 	.inst	0x00000000 ; undefined
--   80058:	30d00800 	.word	0x30d00800
--   8005c:	00000000 	.word	0x00000000
--   80060:	80000000 	.word	0x80000000
--   80064:	00000000 	.word	0x00000000
--   80068:	000001c5 	.word	0x000001c5
--   8006c:	00000000 	.word	0x00000000
--
--Disassembly of section .text:
--
--0000000000080800 <lfb_init>:
--
--/**
-- * Set screen resolution to 1024x768
-- */
--void lfb_init()
--{
--   80800:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
--   80804:	910003fd 	mov	x29, sp
--    mbox[0] = 35*4;
--   80808:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   8080c:	f940bc00 	ldr	x0, [x0, #376]
--   80810:	52801181 	mov	w1, #0x8c                  	// #140
--   80814:	b9000001 	str	w1, [x0]
--    mbox[1] = MBOX_REQUEST;
--   80818:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   8081c:	f940bc00 	ldr	x0, [x0, #376]
--   80820:	b900041f 	str	wzr, [x0, #4]
--
--    mbox[2] = 0x48003;  //set phy wh
--   80824:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80828:	f940bc00 	ldr	x0, [x0, #376]
--   8082c:	52900061 	mov	w1, #0x8003                	// #32771
--   80830:	72a00081 	movk	w1, #0x4, lsl #16
--   80834:	b9000801 	str	w1, [x0, #8]
--    mbox[3] = 8;
--   80838:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   8083c:	f940bc00 	ldr	x0, [x0, #376]
--   80840:	52800101 	mov	w1, #0x8                   	// #8
--   80844:	b9000c01 	str	w1, [x0, #12]
--    mbox[4] = 8;
--   80848:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   8084c:	f940bc00 	ldr	x0, [x0, #376]
--   80850:	52800101 	mov	w1, #0x8                   	// #8
--   80854:	b9001001 	str	w1, [x0, #16]
--    mbox[5] = width;         //FrameBufferInfo.width
--   80858:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8085c:	91186000 	add	x0, x0, #0x618
--   80860:	b9400001 	ldr	w1, [x0]
--   80864:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80868:	f940bc00 	ldr	x0, [x0, #376]
--   8086c:	b9001401 	str	w1, [x0, #20]
--    mbox[6] = height;          //FrameBufferInfo.height
--   80870:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   80874:	91187000 	add	x0, x0, #0x61c
--   80878:	b9400001 	ldr	w1, [x0]
--   8087c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80880:	f940bc00 	ldr	x0, [x0, #376]
--   80884:	b9001801 	str	w1, [x0, #24]
--
--    mbox[7] = 0x48004;  //set virt wh
--   80888:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   8088c:	f940bc00 	ldr	x0, [x0, #376]
--   80890:	52900081 	mov	w1, #0x8004                	// #32772
--   80894:	72a00081 	movk	w1, #0x4, lsl #16
--   80898:	b9001c01 	str	w1, [x0, #28]
--    mbox[8] = 8;
--   8089c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   808a0:	f940bc00 	ldr	x0, [x0, #376]
--   808a4:	52800101 	mov	w1, #0x8                   	// #8
--   808a8:	b9002001 	str	w1, [x0, #32]
--    mbox[9] = 8;
--   808ac:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   808b0:	f940bc00 	ldr	x0, [x0, #376]
--   808b4:	52800101 	mov	w1, #0x8                   	// #8
--   808b8:	b9002401 	str	w1, [x0, #36]
--    mbox[10] = vwidth;        //FrameBufferInfo.virtual_width
--   808bc:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   808c0:	91188000 	add	x0, x0, #0x620
--   808c4:	b9400001 	ldr	w1, [x0]
--   808c8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   808cc:	f940bc00 	ldr	x0, [x0, #376]
--   808d0:	b9002801 	str	w1, [x0, #40]
--    mbox[11] = vheight;         //FrameBufferInfo.virtual_height
--   808d4:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   808d8:	91189000 	add	x0, x0, #0x624
--   808dc:	b9400001 	ldr	w1, [x0]
--   808e0:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   808e4:	f940bc00 	ldr	x0, [x0, #376]
--   808e8:	b9002c01 	str	w1, [x0, #44]
--
--    mbox[12] = 0x48009; //set virt offset
--   808ec:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   808f0:	f940bc00 	ldr	x0, [x0, #376]
--   808f4:	52900121 	mov	w1, #0x8009                	// #32777
--   808f8:	72a00081 	movk	w1, #0x4, lsl #16
--   808fc:	b9003001 	str	w1, [x0, #48]
--    mbox[13] = 8;
--   80900:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80904:	f940bc00 	ldr	x0, [x0, #376]
--   80908:	52800101 	mov	w1, #0x8                   	// #8
--   8090c:	b9003401 	str	w1, [x0, #52]
--    mbox[14] = 8;
--   80910:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80914:	f940bc00 	ldr	x0, [x0, #376]
--   80918:	52800101 	mov	w1, #0x8                   	// #8
--   8091c:	b9003801 	str	w1, [x0, #56]
--    mbox[15] = offsetx;           //FrameBufferInfo.x_offset
--   80920:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80924:	91180000 	add	x0, x0, #0x600
--   80928:	b9400001 	ldr	w1, [x0]
--   8092c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80930:	f940bc00 	ldr	x0, [x0, #376]
--   80934:	b9003c01 	str	w1, [x0, #60]
--    mbox[16] = offsety;           //FrameBufferInfo.y.offset
--   80938:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   8093c:	91181000 	add	x0, x0, #0x604
--   80940:	b9400001 	ldr	w1, [x0]
--   80944:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80948:	f940bc00 	ldr	x0, [x0, #376]
--   8094c:	b9004001 	str	w1, [x0, #64]
--
--    mbox[17] = 0x48005; //set depth
--   80950:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80954:	f940bc00 	ldr	x0, [x0, #376]
--   80958:	529000a1 	mov	w1, #0x8005                	// #32773
--   8095c:	72a00081 	movk	w1, #0x4, lsl #16
--   80960:	b9004401 	str	w1, [x0, #68]
--    mbox[18] = 4;
--   80964:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80968:	f940bc00 	ldr	x0, [x0, #376]
--   8096c:	52800081 	mov	w1, #0x4                   	// #4
--   80970:	b9004801 	str	w1, [x0, #72]
--    mbox[19] = 4;
--   80974:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80978:	f940bc00 	ldr	x0, [x0, #376]
--   8097c:	52800081 	mov	w1, #0x4                   	// #4
--   80980:	b9004c01 	str	w1, [x0, #76]
--    mbox[20] = 32;          //FrameBufferInfo.depth
--   80984:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80988:	f940bc00 	ldr	x0, [x0, #376]
--   8098c:	52800401 	mov	w1, #0x20                  	// #32
--   80990:	b9005001 	str	w1, [x0, #80]
--
--    mbox[21] = 0x48006; //set pixel order
--   80994:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80998:	f940bc00 	ldr	x0, [x0, #376]
--   8099c:	529000c1 	mov	w1, #0x8006                	// #32774
--   809a0:	72a00081 	movk	w1, #0x4, lsl #16
--   809a4:	b9005401 	str	w1, [x0, #84]
--    mbox[22] = 4;
--   809a8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   809ac:	f940bc00 	ldr	x0, [x0, #376]
--   809b0:	52800081 	mov	w1, #0x4                   	// #4
--   809b4:	b9005801 	str	w1, [x0, #88]
--    mbox[23] = 4;
--   809b8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   809bc:	f940bc00 	ldr	x0, [x0, #376]
--   809c0:	52800081 	mov	w1, #0x4                   	// #4
--   809c4:	b9005c01 	str	w1, [x0, #92]
--    mbox[24] = 1;           //RGB, not BGR preferably
--   809c8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   809cc:	f940bc00 	ldr	x0, [x0, #376]
--   809d0:	52800021 	mov	w1, #0x1                   	// #1
--   809d4:	b9006001 	str	w1, [x0, #96]
--
--    mbox[25] = 0x40001; //get framebuffer, gets alignment on request
--   809d8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   809dc:	f940bc00 	ldr	x0, [x0, #376]
--   809e0:	52800021 	mov	w1, #0x1                   	// #1
--   809e4:	72a00081 	movk	w1, #0x4, lsl #16
--   809e8:	b9006401 	str	w1, [x0, #100]
--    mbox[26] = 8;
--   809ec:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   809f0:	f940bc00 	ldr	x0, [x0, #376]
--   809f4:	52800101 	mov	w1, #0x8                   	// #8
--   809f8:	b9006801 	str	w1, [x0, #104]
--    mbox[27] = 8;
--   809fc:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a00:	f940bc00 	ldr	x0, [x0, #376]
--   80a04:	52800101 	mov	w1, #0x8                   	// #8
--   80a08:	b9006c01 	str	w1, [x0, #108]
--    mbox[28] = 4096;        //FrameBufferInfo.pointer
--   80a0c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a10:	f940bc00 	ldr	x0, [x0, #376]
--   80a14:	52820001 	mov	w1, #0x1000                	// #4096
--   80a18:	b9007001 	str	w1, [x0, #112]
--    mbox[29] = 0;           //FrameBufferInfo.size
--   80a1c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a20:	f940bc00 	ldr	x0, [x0, #376]
--   80a24:	b900741f 	str	wzr, [x0, #116]
--
--    mbox[30] = 0x40008; //get pitch
--   80a28:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a2c:	f940bc00 	ldr	x0, [x0, #376]
--   80a30:	52800101 	mov	w1, #0x8                   	// #8
--   80a34:	72a00081 	movk	w1, #0x4, lsl #16
--   80a38:	b9007801 	str	w1, [x0, #120]
--    mbox[31] = 4;
--   80a3c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a40:	f940bc00 	ldr	x0, [x0, #376]
--   80a44:	52800081 	mov	w1, #0x4                   	// #4
--   80a48:	b9007c01 	str	w1, [x0, #124]
--    mbox[32] = 4;
--   80a4c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a50:	f940bc00 	ldr	x0, [x0, #376]
--   80a54:	52800081 	mov	w1, #0x4                   	// #4
--   80a58:	b9008001 	str	w1, [x0, #128]
--    mbox[33] = 0;           //FrameBufferInfo.pitch
--   80a5c:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a60:	f940bc00 	ldr	x0, [x0, #376]
--   80a64:	b900841f 	str	wzr, [x0, #132]
--
--    mbox[34] = MBOX_TAG_LAST;
--   80a68:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a6c:	f940bc00 	ldr	x0, [x0, #376]
--   80a70:	b900881f 	str	wzr, [x0, #136]
--
--    if(mbox_call(MBOX_CH_PROP) && mbox[20]==32 && mbox[28]!=0) {
--   80a74:	52800100 	mov	w0, #0x8                   	// #8
--   80a78:	940006b7 	bl	82554 <mbox_call>
--   80a7c:	7100001f 	cmp	w0, #0x0
--   80a80:	540007e0 	b.eq	80b7c <lfb_init+0x37c>  // b.none
--   80a84:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a88:	f940bc00 	ldr	x0, [x0, #376]
--   80a8c:	b9405000 	ldr	w0, [x0, #80]
--   80a90:	7100801f 	cmp	w0, #0x20
--   80a94:	54000741 	b.ne	80b7c <lfb_init+0x37c>  // b.any
--   80a98:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80a9c:	f940bc00 	ldr	x0, [x0, #376]
--   80aa0:	b9407000 	ldr	w0, [x0, #112]
--   80aa4:	7100001f 	cmp	w0, #0x0
--   80aa8:	540006a0 	b.eq	80b7c <lfb_init+0x37c>  // b.none
--        mbox[28]&=0x3FFFFFFF;
--   80aac:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80ab0:	f940bc00 	ldr	x0, [x0, #376]
--   80ab4:	b9407000 	ldr	w0, [x0, #112]
--   80ab8:	12007401 	and	w1, w0, #0x3fffffff
--   80abc:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80ac0:	f940bc00 	ldr	x0, [x0, #376]
--   80ac4:	b9007001 	str	w1, [x0, #112]
--        width=mbox[5];
--   80ac8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80acc:	f940bc00 	ldr	x0, [x0, #376]
--   80ad0:	b9401401 	ldr	w1, [x0, #20]
--   80ad4:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   80ad8:	91186000 	add	x0, x0, #0x618
--   80adc:	b9000001 	str	w1, [x0]
--        height=mbox[6];
--   80ae0:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80ae4:	f940bc00 	ldr	x0, [x0, #376]
--   80ae8:	b9401801 	ldr	w1, [x0, #24]
--   80aec:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   80af0:	91187000 	add	x0, x0, #0x61c
--   80af4:	b9000001 	str	w1, [x0]
--        pitch=mbox[33];
--   80af8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80afc:	f940bc00 	ldr	x0, [x0, #376]
--   80b00:	b9408401 	ldr	w1, [x0, #132]
--   80b04:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80b08:	9117e000 	add	x0, x0, #0x5f8
--   80b0c:	b9000001 	str	w1, [x0]
--        vwidth=mbox[10];
--   80b10:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80b14:	f940bc00 	ldr	x0, [x0, #376]
--   80b18:	b9402801 	ldr	w1, [x0, #40]
--   80b1c:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   80b20:	91188000 	add	x0, x0, #0x620
--   80b24:	b9000001 	str	w1, [x0]
--        vheight=mbox[11];        
--   80b28:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80b2c:	f940bc00 	ldr	x0, [x0, #376]
--   80b30:	b9402c01 	ldr	w1, [x0, #44]
--   80b34:	f0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   80b38:	91189000 	add	x0, x0, #0x624
--   80b3c:	b9000001 	str	w1, [x0]
--        isrgb=mbox[24];         //get the actual channel order
--   80b40:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80b44:	f940bc00 	ldr	x0, [x0, #376]
--   80b48:	b9406001 	ldr	w1, [x0, #96]
--   80b4c:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80b50:	9117f000 	add	x0, x0, #0x5fc
--   80b54:	b9000001 	str	w1, [x0]
--        lfb=(void*)((unsigned long)mbox[28]);
--   80b58:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80b5c:	f940bc00 	ldr	x0, [x0, #376]
--   80b60:	b9407000 	ldr	w0, [x0, #112]
--   80b64:	2a0003e0 	mov	w0, w0
--   80b68:	aa0003e1 	mov	x1, x0
--   80b6c:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80b70:	9117c000 	add	x0, x0, #0x5f0
--   80b74:	f9000001 	str	x1, [x0]
--   80b78:	14000005 	b	80b8c <lfb_init+0x38c>
--    } else {
--        printf("Unable to set screen resolution to 1024x768x32\n");
--   80b7c:	d0000bc0 	adrp	x0, 1fa000 <bss_end+0xf9150>
--   80b80:	913ae000 	add	x0, x0, #0xeb8
--   80b84:	94000618 	bl	823e4 <tfp_printf>
--    }
--}
--   80b88:	d503201f 	nop
--   80b8c:	d503201f 	nop
--   80b90:	a8c17bfd 	ldp	x29, x30, [sp], #16
--   80b94:	d65f03c0 	ret
--
--0000000000080b98 <lfb_print>:
--
--/**
-- * Display a string using fixed size PSF
-- */
--void lfb_print(int x, int y, char *s)
--{
--   80b98:	d10103ff 	sub	sp, sp, #0x40
--   80b9c:	b9000fe0 	str	w0, [sp, #12]
--   80ba0:	b9000be1 	str	w1, [sp, #8]
--   80ba4:	f90003e2 	str	x2, [sp]
--    // get our font
--    psf_t *font = (psf_t*)&_binary_font_psf_start;
--   80ba8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80bac:	f940d400 	ldr	x0, [x0, #424]
--   80bb0:	f9000fe0 	str	x0, [sp, #24]
--    // draw next character if it's not zero
--    while(*s) {
--   80bb4:	1400007d 	b	80da8 <lfb_print+0x210>
--        // get the offset of the glyph. Need to adjust this to support unicode table
--        unsigned char *glyph = (unsigned char*)&_binary_font_psf_start +
--         font->headersize + (*((unsigned char*)s)<font->numglyph?*s:0)*font->bytesperglyph;
--   80bb8:	f9400fe0 	ldr	x0, [sp, #24]
--   80bbc:	b9400800 	ldr	w0, [x0, #8]
--   80bc0:	2a0003e1 	mov	w1, w0
--   80bc4:	f94003e0 	ldr	x0, [sp]
--   80bc8:	39400000 	ldrb	w0, [x0]
--   80bcc:	2a0003e2 	mov	w2, w0
--   80bd0:	f9400fe0 	ldr	x0, [sp, #24]
--   80bd4:	b9401000 	ldr	w0, [x0, #16]
--   80bd8:	6b00005f 	cmp	w2, w0
--   80bdc:	540000a2 	b.cs	80bf0 <lfb_print+0x58>  // b.hs, b.nlast
--   80be0:	f94003e0 	ldr	x0, [sp]
--   80be4:	39400000 	ldrb	w0, [x0]
--   80be8:	2a0003e2 	mov	w2, w0
--   80bec:	14000002 	b	80bf4 <lfb_print+0x5c>
--   80bf0:	52800002 	mov	w2, #0x0                   	// #0
--   80bf4:	f9400fe0 	ldr	x0, [sp, #24]
--   80bf8:	b9401400 	ldr	w0, [x0, #20]
--   80bfc:	1b007c40 	mul	w0, w2, w0
--   80c00:	2a0003e0 	mov	w0, w0
--   80c04:	8b000021 	add	x1, x1, x0
--        unsigned char *glyph = (unsigned char*)&_binary_font_psf_start +
--   80c08:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80c0c:	f940d400 	ldr	x0, [x0, #424]
--   80c10:	8b000020 	add	x0, x1, x0
--   80c14:	f9001fe0 	str	x0, [sp, #56]
--        // calculate the offset on screen
--        int offs = (y * pitch) + (x * 4);
--   80c18:	b9400be1 	ldr	w1, [sp, #8]
--   80c1c:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80c20:	9117e000 	add	x0, x0, #0x5f8
--   80c24:	b9400000 	ldr	w0, [x0]
--   80c28:	1b007c20 	mul	w0, w1, w0
--   80c2c:	b9400fe1 	ldr	w1, [sp, #12]
--   80c30:	531e7421 	lsl	w1, w1, #2
--   80c34:	0b010000 	add	w0, w0, w1
--   80c38:	b90037e0 	str	w0, [sp, #52]
--        // variables
--        int i,j, line,mask, bytesperline=(font->width+7)/8;
--   80c3c:	f9400fe0 	ldr	x0, [sp, #24]
--   80c40:	b9401c00 	ldr	w0, [x0, #28]
--   80c44:	11001c00 	add	w0, w0, #0x7
--   80c48:	53037c00 	lsr	w0, w0, #3
--   80c4c:	b90017e0 	str	w0, [sp, #20]
--        // handle carrige return
--        if(*s == '\r') {
--   80c50:	f94003e0 	ldr	x0, [sp]
--   80c54:	39400000 	ldrb	w0, [x0]
--   80c58:	7100341f 	cmp	w0, #0xd
--   80c5c:	54000061 	b.ne	80c68 <lfb_print+0xd0>  // b.any
--            x = 0;
--   80c60:	b9000fff 	str	wzr, [sp, #12]
--   80c64:	1400004e 	b	80d9c <lfb_print+0x204>
--        } else
--        // new line
--        if(*s == '\n') {
--   80c68:	f94003e0 	ldr	x0, [sp]
--   80c6c:	39400000 	ldrb	w0, [x0]
--   80c70:	7100281f 	cmp	w0, #0xa
--   80c74:	54000101 	b.ne	80c94 <lfb_print+0xfc>  // b.any
--            x = 0; y += font->height;
--   80c78:	b9000fff 	str	wzr, [sp, #12]
--   80c7c:	f9400fe0 	ldr	x0, [sp, #24]
--   80c80:	b9401801 	ldr	w1, [x0, #24]
--   80c84:	b9400be0 	ldr	w0, [sp, #8]
--   80c88:	0b000020 	add	w0, w1, w0
--   80c8c:	b9000be0 	str	w0, [sp, #8]
--   80c90:	14000043 	b	80d9c <lfb_print+0x204>
--        } else {
--            // display a character
--            for(j=0;j<font->height;j++){
--   80c94:	b9002fff 	str	wzr, [sp, #44]
--   80c98:	14000036 	b	80d70 <lfb_print+0x1d8>
--                // display one row
--                line=offs;
--   80c9c:	b94037e0 	ldr	w0, [sp, #52]
--   80ca0:	b9002be0 	str	w0, [sp, #40]
--                mask=1<<(font->width-1);
--   80ca4:	f9400fe0 	ldr	x0, [sp, #24]
--   80ca8:	b9401c00 	ldr	w0, [x0, #28]
--   80cac:	51000400 	sub	w0, w0, #0x1
--   80cb0:	52800021 	mov	w1, #0x1                   	// #1
--   80cb4:	1ac02020 	lsl	w0, w1, w0
--   80cb8:	b90027e0 	str	w0, [sp, #36]
--                for(i=0;i<font->width;i++){
--   80cbc:	b90033ff 	str	wzr, [sp, #48]
--   80cc0:	1400001a 	b	80d28 <lfb_print+0x190>
--                    // if bit set, we use white color, otherwise black
--                    *((unsigned int*)(lfb + line))=((int)*glyph) & mask?0xFFFFFF:0;
--   80cc4:	f9401fe0 	ldr	x0, [sp, #56]
--   80cc8:	39400000 	ldrb	w0, [x0]
--   80ccc:	2a0003e1 	mov	w1, w0
--   80cd0:	b94027e0 	ldr	w0, [sp, #36]
--   80cd4:	0a000020 	and	w0, w1, w0
--   80cd8:	7100001f 	cmp	w0, #0x0
--   80cdc:	54000060 	b.eq	80ce8 <lfb_print+0x150>  // b.none
--   80ce0:	12bfe000 	mov	w0, #0xffffff              	// #16777215
--   80ce4:	14000002 	b	80cec <lfb_print+0x154>
--   80ce8:	52800000 	mov	w0, #0x0                   	// #0
--   80cec:	f0000001 	adrp	x1, 83000 <irq_invalid_el1t+0x24>
--   80cf0:	9117c021 	add	x1, x1, #0x5f0
--   80cf4:	f9400022 	ldr	x2, [x1]
--   80cf8:	b9802be1 	ldrsw	x1, [sp, #40]
--   80cfc:	8b010041 	add	x1, x2, x1
--   80d00:	b9000020 	str	w0, [x1]
--                    mask>>=1;
--   80d04:	b94027e0 	ldr	w0, [sp, #36]
--   80d08:	13017c00 	asr	w0, w0, #1
--   80d0c:	b90027e0 	str	w0, [sp, #36]
--                    line+=4;
--   80d10:	b9402be0 	ldr	w0, [sp, #40]
--   80d14:	11001000 	add	w0, w0, #0x4
--   80d18:	b9002be0 	str	w0, [sp, #40]
--                for(i=0;i<font->width;i++){
--   80d1c:	b94033e0 	ldr	w0, [sp, #48]
--   80d20:	11000400 	add	w0, w0, #0x1
--   80d24:	b90033e0 	str	w0, [sp, #48]
--   80d28:	f9400fe0 	ldr	x0, [sp, #24]
--   80d2c:	b9401c01 	ldr	w1, [x0, #28]
--   80d30:	b94033e0 	ldr	w0, [sp, #48]
--   80d34:	6b00003f 	cmp	w1, w0
--   80d38:	54fffc68 	b.hi	80cc4 <lfb_print+0x12c>  // b.pmore
--                }
--                // adjust to next line
--                glyph+=bytesperline;
--   80d3c:	b98017e0 	ldrsw	x0, [sp, #20]
--   80d40:	f9401fe1 	ldr	x1, [sp, #56]
--   80d44:	8b000020 	add	x0, x1, x0
--   80d48:	f9001fe0 	str	x0, [sp, #56]
--                offs+=pitch;
--   80d4c:	b94037e1 	ldr	w1, [sp, #52]
--   80d50:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80d54:	9117e000 	add	x0, x0, #0x5f8
--   80d58:	b9400000 	ldr	w0, [x0]
--   80d5c:	0b000020 	add	w0, w1, w0
--   80d60:	b90037e0 	str	w0, [sp, #52]
--            for(j=0;j<font->height;j++){
--   80d64:	b9402fe0 	ldr	w0, [sp, #44]
--   80d68:	11000400 	add	w0, w0, #0x1
--   80d6c:	b9002fe0 	str	w0, [sp, #44]
--   80d70:	f9400fe0 	ldr	x0, [sp, #24]
--   80d74:	b9401801 	ldr	w1, [x0, #24]
--   80d78:	b9402fe0 	ldr	w0, [sp, #44]
--   80d7c:	6b00003f 	cmp	w1, w0
--   80d80:	54fff8e8 	b.hi	80c9c <lfb_print+0x104>  // b.pmore
--            }
--            x += (font->width+1);
--   80d84:	f9400fe0 	ldr	x0, [sp, #24]
--   80d88:	b9401c01 	ldr	w1, [x0, #28]
--   80d8c:	b9400fe0 	ldr	w0, [sp, #12]
--   80d90:	0b000020 	add	w0, w1, w0
--   80d94:	11000400 	add	w0, w0, #0x1
--   80d98:	b9000fe0 	str	w0, [sp, #12]
--        }
--        // next character
--        s++;
--   80d9c:	f94003e0 	ldr	x0, [sp]
--   80da0:	91000400 	add	x0, x0, #0x1
--   80da4:	f90003e0 	str	x0, [sp]
--    while(*s) {
--   80da8:	f94003e0 	ldr	x0, [sp]
--   80dac:	39400000 	ldrb	w0, [x0]
--   80db0:	7100001f 	cmp	w0, #0x0
--   80db4:	54fff021 	b.ne	80bb8 <lfb_print+0x20>  // b.any
--    }
--}
--   80db8:	d503201f 	nop
--   80dbc:	d503201f 	nop
--   80dc0:	910103ff 	add	sp, sp, #0x40
--   80dc4:	d65f03c0 	ret
--
--0000000000080dc8 <lfb_print_update>:
--
--// x/y IN|OUT: the postion before/after the screen output
--void lfb_print_update(int *x, int *y, char *s)
--{
--   80dc8:	d10143ff 	sub	sp, sp, #0x50
--   80dcc:	f9000fe0 	str	x0, [sp, #24]
--   80dd0:	f9000be1 	str	x1, [sp, #16]
--   80dd4:	f90007e2 	str	x2, [sp, #8]
--    // get our font
--    psf_t *font = (psf_t*)&_binary_font_psf_start;
--   80dd8:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80ddc:	f940d400 	ldr	x0, [x0, #424]
--   80de0:	f90017e0 	str	x0, [sp, #40]
--    // draw next character if it's not zero
--    while(*s) {
--   80de4:	1400008a 	b	8100c <lfb_print_update+0x244>
--        // get the offset of the glyph. Need to adjust this to support unicode table
--        unsigned char *glyph = (unsigned char*)&_binary_font_psf_start +
--         font->headersize + (*((unsigned char*)s)<font->numglyph?*s:0)*font->bytesperglyph;
--   80de8:	f94017e0 	ldr	x0, [sp, #40]
--   80dec:	b9400800 	ldr	w0, [x0, #8]
--   80df0:	2a0003e1 	mov	w1, w0
--   80df4:	f94007e0 	ldr	x0, [sp, #8]
--   80df8:	39400000 	ldrb	w0, [x0]
--   80dfc:	2a0003e2 	mov	w2, w0
--   80e00:	f94017e0 	ldr	x0, [sp, #40]
--   80e04:	b9401000 	ldr	w0, [x0, #16]
--   80e08:	6b00005f 	cmp	w2, w0
--   80e0c:	540000a2 	b.cs	80e20 <lfb_print_update+0x58>  // b.hs, b.nlast
--   80e10:	f94007e0 	ldr	x0, [sp, #8]
--   80e14:	39400000 	ldrb	w0, [x0]
--   80e18:	2a0003e2 	mov	w2, w0
--   80e1c:	14000002 	b	80e24 <lfb_print_update+0x5c>
--   80e20:	52800002 	mov	w2, #0x0                   	// #0
--   80e24:	f94017e0 	ldr	x0, [sp, #40]
--   80e28:	b9401400 	ldr	w0, [x0, #20]
--   80e2c:	1b007c40 	mul	w0, w2, w0
--   80e30:	2a0003e0 	mov	w0, w0
--   80e34:	8b000021 	add	x1, x1, x0
--        unsigned char *glyph = (unsigned char*)&_binary_font_psf_start +
--   80e38:	90000be0 	adrp	x0, 1fc000 <task+0x90>
--   80e3c:	f940d400 	ldr	x0, [x0, #424]
--   80e40:	8b000020 	add	x0, x1, x0
--   80e44:	f90027e0 	str	x0, [sp, #72]
--        // calculate the offset on screen
--        int offs = (*y * pitch) + (*x * 4);
--   80e48:	f9400be0 	ldr	x0, [sp, #16]
--   80e4c:	b9400000 	ldr	w0, [x0]
--   80e50:	2a0003e1 	mov	w1, w0
--   80e54:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80e58:	9117e000 	add	x0, x0, #0x5f8
--   80e5c:	b9400000 	ldr	w0, [x0]
--   80e60:	1b007c20 	mul	w0, w1, w0
--   80e64:	f9400fe1 	ldr	x1, [sp, #24]
--   80e68:	b9400021 	ldr	w1, [x1]
--   80e6c:	531e7421 	lsl	w1, w1, #2
--   80e70:	0b010000 	add	w0, w0, w1
--   80e74:	b90047e0 	str	w0, [sp, #68]
--        // variables
--        int i,j, line,mask, bytesperline=(font->width+7)/8;
--   80e78:	f94017e0 	ldr	x0, [sp, #40]
--   80e7c:	b9401c00 	ldr	w0, [x0, #28]
--   80e80:	11001c00 	add	w0, w0, #0x7
--   80e84:	53037c00 	lsr	w0, w0, #3
--   80e88:	b90027e0 	str	w0, [sp, #36]
--        // handle carrige return
--        if(*s == '\r') {
--   80e8c:	f94007e0 	ldr	x0, [sp, #8]
--   80e90:	39400000 	ldrb	w0, [x0]
--   80e94:	7100341f 	cmp	w0, #0xd
--   80e98:	54000081 	b.ne	80ea8 <lfb_print_update+0xe0>  // b.any
--            *x = 0;
--   80e9c:	f9400fe0 	ldr	x0, [sp, #24]
--   80ea0:	b900001f 	str	wzr, [x0]
--   80ea4:	14000057 	b	81000 <lfb_print_update+0x238>
--        } else
--        // new line
--        if(*s == '\n') {
--   80ea8:	f94007e0 	ldr	x0, [sp, #8]
--   80eac:	39400000 	ldrb	w0, [x0]
--   80eb0:	7100281f 	cmp	w0, #0xa
--   80eb4:	540001a1 	b.ne	80ee8 <lfb_print_update+0x120>  // b.any
--            *x = 0; *y += font->height;
--   80eb8:	f9400fe0 	ldr	x0, [sp, #24]
--   80ebc:	b900001f 	str	wzr, [x0]
--   80ec0:	f9400be0 	ldr	x0, [sp, #16]
--   80ec4:	b9400000 	ldr	w0, [x0]
--   80ec8:	2a0003e1 	mov	w1, w0
--   80ecc:	f94017e0 	ldr	x0, [sp, #40]
--   80ed0:	b9401800 	ldr	w0, [x0, #24]
--   80ed4:	0b000020 	add	w0, w1, w0
--   80ed8:	2a0003e1 	mov	w1, w0
--   80edc:	f9400be0 	ldr	x0, [sp, #16]
--   80ee0:	b9000001 	str	w1, [x0]
--   80ee4:	14000047 	b	81000 <lfb_print_update+0x238>
--        } else {
--            // display a character
--            for(j=0;j<font->height;j++){
--   80ee8:	b9003fff 	str	wzr, [sp, #60]
--   80eec:	14000036 	b	80fc4 <lfb_print_update+0x1fc>
--                // display one row
--                line=offs;
--   80ef0:	b94047e0 	ldr	w0, [sp, #68]
--   80ef4:	b9003be0 	str	w0, [sp, #56]
--                mask=1<<(font->width-1);
--   80ef8:	f94017e0 	ldr	x0, [sp, #40]
--   80efc:	b9401c00 	ldr	w0, [x0, #28]
--   80f00:	51000400 	sub	w0, w0, #0x1
--   80f04:	52800021 	mov	w1, #0x1                   	// #1
--   80f08:	1ac02020 	lsl	w0, w1, w0
--   80f0c:	b90037e0 	str	w0, [sp, #52]
--                for(i=0;i<font->width;i++){
--   80f10:	b90043ff 	str	wzr, [sp, #64]
--   80f14:	1400001a 	b	80f7c <lfb_print_update+0x1b4>
--                    // if bit set, we use white color, otherwise black
--                    *((unsigned int*)(lfb + line))=((int)*glyph) & mask?0xFFFFFF:0;
--   80f18:	f94027e0 	ldr	x0, [sp, #72]
--   80f1c:	39400000 	ldrb	w0, [x0]
--   80f20:	2a0003e1 	mov	w1, w0
--   80f24:	b94037e0 	ldr	w0, [sp, #52]
--   80f28:	0a000020 	and	w0, w1, w0
--   80f2c:	7100001f 	cmp	w0, #0x0
--   80f30:	54000060 	b.eq	80f3c <lfb_print_update+0x174>  // b.none
--   80f34:	12bfe000 	mov	w0, #0xffffff              	// #16777215
--   80f38:	14000002 	b	80f40 <lfb_print_update+0x178>
--   80f3c:	52800000 	mov	w0, #0x0                   	// #0
--   80f40:	f0000001 	adrp	x1, 83000 <irq_invalid_el1t+0x24>
--   80f44:	9117c021 	add	x1, x1, #0x5f0
--   80f48:	f9400022 	ldr	x2, [x1]
--   80f4c:	b9803be1 	ldrsw	x1, [sp, #56]
--   80f50:	8b010041 	add	x1, x2, x1
--   80f54:	b9000020 	str	w0, [x1]
--                    mask>>=1;
--   80f58:	b94037e0 	ldr	w0, [sp, #52]
--   80f5c:	13017c00 	asr	w0, w0, #1
--   80f60:	b90037e0 	str	w0, [sp, #52]
--                    line+=4;
--   80f64:	b9403be0 	ldr	w0, [sp, #56]
--   80f68:	11001000 	add	w0, w0, #0x4
--   80f6c:	b9003be0 	str	w0, [sp, #56]
--                for(i=0;i<font->width;i++){
--   80f70:	b94043e0 	ldr	w0, [sp, #64]
--   80f74:	11000400 	add	w0, w0, #0x1
--   80f78:	b90043e0 	str	w0, [sp, #64]
--   80f7c:	f94017e0 	ldr	x0, [sp, #40]
--   80f80:	b9401c01 	ldr	w1, [x0, #28]
--   80f84:	b94043e0 	ldr	w0, [sp, #64]
--   80f88:	6b00003f 	cmp	w1, w0
--   80f8c:	54fffc68 	b.hi	80f18 <lfb_print_update+0x150>  // b.pmore
--                }
--                // adjust to next line
--                glyph+=bytesperline;
--   80f90:	b98027e0 	ldrsw	x0, [sp, #36]
--   80f94:	f94027e1 	ldr	x1, [sp, #72]
--   80f98:	8b000020 	add	x0, x1, x0
--   80f9c:	f90027e0 	str	x0, [sp, #72]
--                offs+=pitch;
--   80fa0:	b94047e1 	ldr	w1, [sp, #68]
--   80fa4:	f0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   80fa8:	9117e000 	add	x0, x0, #0x5f8
--   80fac:	b9400000 	ldr	w0, [x0]
--   80fb0:	0b000020 	add	w0, w1, w0
--   80fb4:	b90047e0 	str	w0, [sp, #68]
--            for(j=0;j<font->height;j++){
--   80fb8:	b9403fe0 	ldr	w0, [sp, #60]
--   80fbc:	11000400 	add	w0, w0, #0x1
--   80fc0:	b9003fe0 	str	w0, [sp, #60]
--   80fc4:	f94017e0 	ldr	x0, [sp, #40]
--   80fc8:	b9401801 	ldr	w1, [x0, #24]
--   80fcc:	b9403fe0 	ldr	w0, [sp, #60]
--   80fd0:	6b00003f 	cmp	w1, w0
--   80fd4:	54fff8e8 	b.hi	80ef0 <lfb_print_update+0x128>  // b.pmore
--            }
--            *x += (font->width+1);
--   80fd8:	f9400fe0 	ldr	x0, [sp, #24]
--   80fdc:	b9400000 	ldr	w0, [x0]
--   80fe0:	2a0003e1 	mov	w1, w0
--   80fe4:	f94017e0 	ldr	x0, [sp, #40]
--   80fe8:	b9401c00 	ldr	w0, [x0, #28]
--   80fec:	0b000020 	add	w0, w1, w0
--   80ff0:	11000400 	add	w0, w0, #0x1
--   80ff4:	2a0003e1 	mov	w1, w0
--   80ff8:	f9400fe0 	ldr	x0, [sp, #24]
--   80ffc:	b9000001 	str	w1, [x0]
--        }
--        // next character
--        s++;
--   81000:	f94007e0 	ldr	x0, [sp, #8]
--   81004:	91000400 	add	x0, x0, #0x1
--   81008:	f90007e0 	str	x0, [sp, #8]
--    while(*s) {
--   8100c:	f94007e0 	ldr	x0, [sp, #8]
--   81010:	39400000 	ldrb	w0, [x0]
--   81014:	7100001f 	cmp	w0, #0x0
--   81018:	54ffee81 	b.ne	80de8 <lfb_print_update+0x20>  // b.any
--    }
--}
--   8101c:	d503201f 	nop
--   81020:	d503201f 	nop
--   81024:	910143ff 	add	sp, sp, #0x50
--   81028:	d65f03c0 	ret
--
--000000000008102c <lfb_showpicture>:
--#define IMG_DATA img_data      
--#define IMG_HEIGHT img_height
--#define IMG_WIDTH img_width
--
--void lfb_showpicture()
--{
--   8102c:	d100c3ff 	sub	sp, sp, #0x30
--    int x,y;
--    unsigned char *ptr=lfb;
--   81030:	d0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   81034:	9117c000 	add	x0, x0, #0x5f0
--   81038:	f9400000 	ldr	x0, [x0]
--   8103c:	f90013e0 	str	x0, [sp, #32]
--    char *data=IMG_DATA, pixel[4];
--   81040:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81044:	913b8000 	add	x0, x0, #0xee0
--   81048:	f9400000 	ldr	x0, [x0]
--   8104c:	f9000fe0 	str	x0, [sp, #24]
--    // fill framebuf. crop img data per the framebuf size
--    unsigned int img_fb_height = vheight < IMG_HEIGHT ? vheight : IMG_HEIGHT; 
--   81050:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81054:	91185000 	add	x0, x0, #0x614
--   81058:	b9400001 	ldr	w1, [x0]
--   8105c:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81060:	91189000 	add	x0, x0, #0x624
--   81064:	b9400000 	ldr	w0, [x0]
--   81068:	6b00003f 	cmp	w1, w0
--   8106c:	1a809020 	csel	w0, w1, w0, ls  // ls = plast
--   81070:	b90017e0 	str	w0, [sp, #20]
--    unsigned int img_fb_width = vwidth < IMG_WIDTH ? vwidth : IMG_WIDTH; 
--   81074:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81078:	91184000 	add	x0, x0, #0x610
--   8107c:	b9400001 	ldr	w1, [x0]
--   81080:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81084:	91188000 	add	x0, x0, #0x620
--   81088:	b9400000 	ldr	w0, [x0]
--   8108c:	6b00003f 	cmp	w1, w0
--   81090:	1a809020 	csel	w0, w1, w0, ls  // ls = plast
--   81094:	b90013e0 	str	w0, [sp, #16]
--
--    // xzl: copy the image pixels to the start (top) of framebuf    
--    //ptr += (vheight-img_fb_height)/2*pitch + (vwidth-img_fb_width)*2;  
--    ptr += (vwidth-img_fb_width)*2;  
--   81098:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8109c:	91188000 	add	x0, x0, #0x620
--   810a0:	b9400001 	ldr	w1, [x0]
--   810a4:	b94013e0 	ldr	w0, [sp, #16]
--   810a8:	4b000020 	sub	w0, w1, w0
--   810ac:	531f7800 	lsl	w0, w0, #1
--   810b0:	2a0003e0 	mov	w0, w0
--   810b4:	f94013e1 	ldr	x1, [sp, #32]
--   810b8:	8b000020 	add	x0, x1, x0
--   810bc:	f90013e0 	str	x0, [sp, #32]
--    
--    for(y=0;y<img_fb_height;y++) {
--   810c0:	b9002bff 	str	wzr, [sp, #40]
--   810c4:	1400005d 	b	81238 <lfb_showpicture+0x20c>
--        for(x=0;x<img_fb_width;x++) {
--   810c8:	b9002fff 	str	wzr, [sp, #44]
--   810cc:	1400004a 	b	811f4 <lfb_showpicture+0x1c8>
--            HEADER_PIXEL(data, pixel);
--   810d0:	f9400fe0 	ldr	x0, [sp, #24]
--   810d4:	39400000 	ldrb	w0, [x0]
--   810d8:	51008400 	sub	w0, w0, #0x21
--   810dc:	531e7400 	lsl	w0, w0, #2
--   810e0:	13001c01 	sxtb	w1, w0
--   810e4:	f9400fe0 	ldr	x0, [sp, #24]
--   810e8:	91000400 	add	x0, x0, #0x1
--   810ec:	39400000 	ldrb	w0, [x0]
--   810f0:	51008400 	sub	w0, w0, #0x21
--   810f4:	13047c00 	asr	w0, w0, #4
--   810f8:	13001c00 	sxtb	w0, w0
--   810fc:	2a000020 	orr	w0, w1, w0
--   81100:	13001c00 	sxtb	w0, w0
--   81104:	12001c00 	and	w0, w0, #0xff
--   81108:	390023e0 	strb	w0, [sp, #8]
--   8110c:	f9400fe0 	ldr	x0, [sp, #24]
--   81110:	91000400 	add	x0, x0, #0x1
--   81114:	39400000 	ldrb	w0, [x0]
--   81118:	51008400 	sub	w0, w0, #0x21
--   8111c:	531c6c00 	lsl	w0, w0, #4
--   81120:	13001c01 	sxtb	w1, w0
--   81124:	f9400fe0 	ldr	x0, [sp, #24]
--   81128:	91000800 	add	x0, x0, #0x2
--   8112c:	39400000 	ldrb	w0, [x0]
--   81130:	51008400 	sub	w0, w0, #0x21
--   81134:	13027c00 	asr	w0, w0, #2
--   81138:	13001c00 	sxtb	w0, w0
--   8113c:	2a000020 	orr	w0, w1, w0
--   81140:	13001c00 	sxtb	w0, w0
--   81144:	12001c00 	and	w0, w0, #0xff
--   81148:	390027e0 	strb	w0, [sp, #9]
--   8114c:	f9400fe0 	ldr	x0, [sp, #24]
--   81150:	91000800 	add	x0, x0, #0x2
--   81154:	39400000 	ldrb	w0, [x0]
--   81158:	51008400 	sub	w0, w0, #0x21
--   8115c:	531a6400 	lsl	w0, w0, #6
--   81160:	13001c01 	sxtb	w1, w0
--   81164:	f9400fe0 	ldr	x0, [sp, #24]
--   81168:	91000c00 	add	x0, x0, #0x3
--   8116c:	39400000 	ldrb	w0, [x0]
--   81170:	51008400 	sub	w0, w0, #0x21
--   81174:	12001c00 	and	w0, w0, #0xff
--   81178:	13001c00 	sxtb	w0, w0
--   8117c:	2a000020 	orr	w0, w1, w0
--   81180:	13001c00 	sxtb	w0, w0
--   81184:	12001c00 	and	w0, w0, #0xff
--   81188:	39002be0 	strb	w0, [sp, #10]
--   8118c:	f9400fe0 	ldr	x0, [sp, #24]
--   81190:	91001000 	add	x0, x0, #0x4
--   81194:	f9000fe0 	str	x0, [sp, #24]
--            // the image is in RGB. So if we have an RGB framebuffer, we can copy the pixels
--            // directly, but for BGR we must swap R (pixel[0]) and B (pixel[2]) channels.
--            *((unsigned int*)ptr)=isrgb ? *((unsigned int *)&pixel) : (unsigned int)(pixel[0]<<16 | pixel[1]<<8 | pixel[2]);
--   81198:	d0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   8119c:	9117f000 	add	x0, x0, #0x5fc
--   811a0:	b9400000 	ldr	w0, [x0]
--   811a4:	7100001f 	cmp	w0, #0x0
--   811a8:	54000080 	b.eq	811b8 <lfb_showpicture+0x18c>  // b.none
--   811ac:	910023e0 	add	x0, sp, #0x8
--   811b0:	b9400000 	ldr	w0, [x0]
--   811b4:	14000008 	b	811d4 <lfb_showpicture+0x1a8>
--   811b8:	394023e0 	ldrb	w0, [sp, #8]
--   811bc:	53103c01 	lsl	w1, w0, #16
--   811c0:	394027e0 	ldrb	w0, [sp, #9]
--   811c4:	53185c00 	lsl	w0, w0, #8
--   811c8:	2a000020 	orr	w0, w1, w0
--   811cc:	39402be1 	ldrb	w1, [sp, #10]
--   811d0:	2a010000 	orr	w0, w0, w1
--   811d4:	f94013e1 	ldr	x1, [sp, #32]
--   811d8:	b9000020 	str	w0, [x1]
--            ptr+=4;
--   811dc:	f94013e0 	ldr	x0, [sp, #32]
--   811e0:	91001000 	add	x0, x0, #0x4
--   811e4:	f90013e0 	str	x0, [sp, #32]
--        for(x=0;x<img_fb_width;x++) {
--   811e8:	b9402fe0 	ldr	w0, [sp, #44]
--   811ec:	11000400 	add	w0, w0, #0x1
--   811f0:	b9002fe0 	str	w0, [sp, #44]
--   811f4:	b9402fe0 	ldr	w0, [sp, #44]
--   811f8:	b94013e1 	ldr	w1, [sp, #16]
--   811fc:	6b00003f 	cmp	w1, w0
--   81200:	54fff688 	b.hi	810d0 <lfb_showpicture+0xa4>  // b.pmore
--        }
--        ptr+=pitch-img_fb_width*4;
--   81204:	d0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   81208:	9117e000 	add	x0, x0, #0x5f8
--   8120c:	b9400001 	ldr	w1, [x0]
--   81210:	b94013e0 	ldr	w0, [sp, #16]
--   81214:	531e7400 	lsl	w0, w0, #2
--   81218:	4b000020 	sub	w0, w1, w0
--   8121c:	2a0003e0 	mov	w0, w0
--   81220:	f94013e1 	ldr	x1, [sp, #32]
--   81224:	8b000020 	add	x0, x1, x0
--   81228:	f90013e0 	str	x0, [sp, #32]
--    for(y=0;y<img_fb_height;y++) {
--   8122c:	b9402be0 	ldr	w0, [sp, #40]
--   81230:	11000400 	add	w0, w0, #0x1
--   81234:	b9002be0 	str	w0, [sp, #40]
--   81238:	b9402be0 	ldr	w0, [sp, #40]
--   8123c:	b94017e1 	ldr	w1, [sp, #20]
--   81240:	6b00003f 	cmp	w1, w0
--   81244:	54fff428 	b.hi	810c8 <lfb_showpicture+0x9c>  // b.pmore
--    }
--   81248:	d503201f 	nop
--   8124c:	d503201f 	nop
--   81250:	9100c3ff 	add	sp, sp, #0x30
--   81254:	d65f03c0 	ret
--
--0000000000081258 <sleep>:
--#else
--#define CHAR_DELAY (1000000)
--#endif
--
--void sleep(int x)
--{
--   81258:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   8125c:	910003fd 	mov	x29, sp
--   81260:	b9001fe0 	str	w0, [sp, #28]
--        current->delay_sec = x;
--   81264:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81268:	f940c000 	ldr	x0, [x0, #384]
--   8126c:	f9400000 	ldr	x0, [x0]
--   81270:	b9801fe1 	ldrsw	x1, [sp, #28]
--   81274:	f9004001 	str	x1, [x0, #128]
--        current->state = TASK_WAITING;
--   81278:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   8127c:	f940c000 	ldr	x0, [x0, #384]
--   81280:	f9400000 	ldr	x0, [x0]
--   81284:	d2800021 	mov	x1, #0x1                   	// #1
--   81288:	f9003401 	str	x1, [x0, #104]
--        schedule();
--   8128c:	94000170 	bl	8184c <schedule>
--}
--   81290:	d503201f 	nop
--   81294:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   81298:	d65f03c0 	ret
--
--000000000008129c <process>:
--
--void process(char *array)
--{
--   8129c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
--   812a0:	910003fd 	mov	x29, sp
--   812a4:	f9000fe0 	str	x0, [sp, #24]
--		scr_x = 0; scr_y = 480; 
--	}
--#endif 
--
--	while (1){
--		for (int i = 0; i < 5; i++){
--   812a8:	b9002fff 	str	wzr, [sp, #44]
--   812ac:	1400000c 	b	812dc <process+0x40>
--			uart_send(array[i]);
--   812b0:	b9802fe0 	ldrsw	x0, [sp, #44]
--   812b4:	f9400fe1 	ldr	x1, [sp, #24]
--   812b8:	8b000020 	add	x0, x1, x0
--   812bc:	39400000 	ldrb	w0, [x0]
--   812c0:	940000a0 	bl	81540 <uart_send>
--			lfb_print_update(&scr_x, &scr_y, array+i);
--			array[i+1] = c; 
--			if (scr_x > 1024)
--				lfb_print_update(&scr_x, &scr_y, "\n");
--#endif
--			delay(CHAR_DELAY);
--   812c4:	d28f0800 	mov	x0, #0x7840                	// #30784
--   812c8:	f2a02fa0 	movk	x0, #0x17d, lsl #16
--   812cc:	940008c6 	bl	835e4 <delay>
--		for (int i = 0; i < 5; i++){
--   812d0:	b9402fe0 	ldr	w0, [sp, #44]
--   812d4:	11000400 	add	w0, w0, #0x1
--   812d8:	b9002fe0 	str	w0, [sp, #44]
--   812dc:	b9402fe0 	ldr	w0, [sp, #44]
--   812e0:	7100101f 	cmp	w0, #0x4
--   812e4:	54fffe6d 	b.le	812b0 <process+0x14>
--		} 
--		if (array[0] == 'a')
--   812e8:	f9400fe0 	ldr	x0, [sp, #24]
--   812ec:	39400000 	ldrb	w0, [x0]
--   812f0:	7101841f 	cmp	w0, #0x61
--   812f4:	54000081 	b.ne	81304 <process+0x68>  // b.any
--			sleep(3);
--   812f8:	52800060 	mov	w0, #0x3                   	// #3
--   812fc:	97ffffd7 	bl	81258 <sleep>
--   81300:	14000007 	b	8131c <process+0x80>
--		else if (array[0] == '1')
--   81304:	f9400fe0 	ldr	x0, [sp, #24]
--   81308:	39400000 	ldrb	w0, [x0]
--   8130c:	7100c41f 	cmp	w0, #0x31
--   81310:	54000061 	b.ne	8131c <process+0x80>  // b.any
--			sleep(5);
--   81314:	528000a0 	mov	w0, #0x5                   	// #5
--   81318:	97ffffd0 	bl	81258 <sleep>
--		schedule(); // yield
--   8131c:	9400014c 	bl	8184c <schedule>
--		for (int i = 0; i < 5; i++){
--   81320:	17ffffe2 	b	812a8 <process+0xc>
--
--0000000000081324 <kernel_main>:
--	}
--}
--
--void kernel_main(void)
--{
--   81324:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   81328:	910003fd 	mov	x29, sp
--	uart_init();
--   8132c:	940000bf 	bl	81628 <uart_init>
--	init_printf(0, putc);
--   81330:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81334:	f940cc01 	ldr	x1, [x0, #408]
--   81338:	d2800000 	mov	x0, #0x0                   	// #0
--   8133c:	9400041c 	bl	823ac <init_printf>
--
--	printf("kernel boots\r\n");
--   81340:	b0000bc0 	adrp	x0, 1fa000 <bss_end+0xf9150>
--   81344:	913ba000 	add	x0, x0, #0xee8
--   81348:	94000427 	bl	823e4 <tfp_printf>
--
--	irq_vector_init();
--   8134c:	94000880 	bl	8354c <irq_vector_init>
--	generic_timer_init();
--   81350:	94000169 	bl	818f4 <generic_timer_init>
--	enable_interrupt_controller();
--   81354:	94000024 	bl	813e4 <enable_interrupt_controller>
--	enable_irq();
--   81358:	94000880 	bl	83558 <enable_irq>
--	lfb_init(); 
--	lfb_showpicture();
--	lfb_print(0, 240, "kernel boots");
--#endif		
--
--	int res = copy_process((unsigned long)&process, (unsigned long)"12345");
--   8135c:	90000000 	adrp	x0, 81000 <lfb_print_update+0x238>
--   81360:	910a7002 	add	x2, x0, #0x29c
--   81364:	b0000bc0 	adrp	x0, 1fa000 <bss_end+0xf9150>
--   81368:	913be000 	add	x0, x0, #0xef8
--   8136c:	aa0003e1 	mov	x1, x0
--   81370:	aa0203e0 	mov	x0, x2
--   81374:	940001ef 	bl	81b30 <copy_process>
--   81378:	b9001fe0 	str	w0, [sp, #28]
--	if (res != 0) {
--   8137c:	b9401fe0 	ldr	w0, [sp, #28]
--   81380:	7100001f 	cmp	w0, #0x0
--   81384:	540000a0 	b.eq	81398 <kernel_main+0x74>  // b.none
--		printf("error while starting process 1");
--   81388:	b0000bc0 	adrp	x0, 1fa000 <bss_end+0xf9150>
--   8138c:	913c0000 	add	x0, x0, #0xf00
--   81390:	94000415 	bl	823e4 <tfp_printf>
--		return;
--   81394:	14000012 	b	813dc <kernel_main+0xb8>
--	}
--	
--	res = copy_process((unsigned long)&process, (unsigned long)"abcde");
--   81398:	90000000 	adrp	x0, 81000 <lfb_print_update+0x238>
--   8139c:	910a7002 	add	x2, x0, #0x29c
--   813a0:	b0000bc0 	adrp	x0, 1fa000 <bss_end+0xf9150>
--   813a4:	913c8000 	add	x0, x0, #0xf20
--   813a8:	aa0003e1 	mov	x1, x0
--   813ac:	aa0203e0 	mov	x0, x2
--   813b0:	940001e0 	bl	81b30 <copy_process>
--   813b4:	b9001fe0 	str	w0, [sp, #28]
--	if (res != 0) {
--   813b8:	b9401fe0 	ldr	w0, [sp, #28]
--   813bc:	7100001f 	cmp	w0, #0x0
--   813c0:	540000a0 	b.eq	813d4 <kernel_main+0xb0>  // b.none
--		printf("error while starting process 2");
--   813c4:	b0000bc0 	adrp	x0, 1fa000 <bss_end+0xf9150>
--   813c8:	913ca000 	add	x0, x0, #0xf28
--   813cc:	94000406 	bl	823e4 <tfp_printf>
--		return;
--   813d0:	14000003 	b	813dc <kernel_main+0xb8>
--	}
--
--	while (1){
--		schedule();
--   813d4:	9400011e 	bl	8184c <schedule>
--   813d8:	17ffffff 	b	813d4 <kernel_main+0xb0>
--	}	
--}
--   813dc:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   813e0:	d65f03c0 	ret
--
--00000000000813e4 <enable_interrupt_controller>:
--    "FIQ_INVALID_EL0_32",		
--    "ERROR_INVALID_EL0_32"	
--};
--
--void enable_interrupt_controller()
--{
--   813e4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
--   813e8:	910003fd 	mov	x29, sp
--//    // Enables Core 0 Timers interrupt control for the generic timer
--    put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
--   813ec:	52800041 	mov	w1, #0x2                   	// #2
--   813f0:	d2800800 	mov	x0, #0x40                  	// #64
--   813f4:	f2a80000 	movk	x0, #0x4000, lsl #16
--   813f8:	94000877 	bl	835d4 <put32>
--}
--   813fc:	d503201f 	nop
--   81400:	a8c17bfd 	ldp	x29, x30, [sp], #16
--   81404:	d65f03c0 	ret
--
--0000000000081408 <handle_irq>:
--
--
--void handle_irq(void)
--{
--   81408:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   8140c:	910003fd 	mov	x29, sp
--    // Each Core has its own pending local intrrupts register
--    unsigned int irq = get32(INT_SOURCE_0);
--   81410:	d2800c00 	mov	x0, #0x60                  	// #96
--   81414:	f2a80000 	movk	x0, #0x4000, lsl #16
--   81418:	94000871 	bl	835dc <get32>
--   8141c:	b9001fe0 	str	w0, [sp, #28]
--    switch (irq) {
--   81420:	b9401fe0 	ldr	w0, [sp, #28]
--   81424:	7100081f 	cmp	w0, #0x2
--   81428:	54000061 	b.ne	81434 <handle_irq+0x2c>  // b.any
--        case (GENERIC_TIMER_INTERRUPT):
--        	handle_generic_timer_irq();
--   8142c:	94000149 	bl	81950 <handle_generic_timer_irq>
--        	break;
--   81430:	14000006 	b	81448 <handle_irq+0x40>
--	default:
--		printf("We do not expect pending irq to happen: %x\r\n", irq);
--   81434:	b9401fe1 	ldr	w1, [sp, #28]
--   81438:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8143c:	91032000 	add	x0, x0, #0xc8
--   81440:	940003e9 	bl	823e4 <tfp_printf>
--	//while (1)
--	//	;
--    }
--}
--   81444:	d503201f 	nop
--   81448:	d503201f 	nop
--   8144c:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   81450:	d65f03c0 	ret
--
--0000000000081454 <show_invalid_entry_message>:
--
--void show_invalid_entry_message(int type, unsigned long esr, unsigned long address)
--{
--   81454:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
--   81458:	910003fd 	mov	x29, sp
--   8145c:	b9002fe0 	str	w0, [sp, #44]
--   81460:	f90013e1 	str	x1, [sp, #32]
--   81464:	f9000fe2 	str	x2, [sp, #24]
--    printf("%s, ESR: %x, address: %x\r\n", entry_error_messages[type], esr, address);
--   81468:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8146c:	913ba000 	add	x0, x0, #0xee8
--   81470:	b9802fe1 	ldrsw	x1, [sp, #44]
--   81474:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   81478:	f9400fe3 	ldr	x3, [sp, #24]
--   8147c:	f94013e2 	ldr	x2, [sp, #32]
--   81480:	aa0003e1 	mov	x1, x0
--   81484:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81488:	9103e000 	add	x0, x0, #0xf8
--   8148c:	940003d6 	bl	823e4 <tfp_printf>
--}
--   81490:	d503201f 	nop
--   81494:	a8c37bfd 	ldp	x29, x30, [sp], #48
--   81498:	d65f03c0 	ret
--
--000000000008149c <get_free_page>:
--#include "mm.h"
--
--static unsigned short mem_map [ PAGING_PAGES ] = {0,};
--
--unsigned long get_free_page()
--{
--   8149c:	d10043ff 	sub	sp, sp, #0x10
--	for (int i = 0; i < PAGING_PAGES; i++){
--   814a0:	b9000fff 	str	wzr, [sp, #12]
--   814a4:	14000014 	b	814f4 <get_free_page+0x58>
--		if (mem_map[i] == 0){
--   814a8:	d0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   814ac:	91182000 	add	x0, x0, #0x608
--   814b0:	b9800fe1 	ldrsw	x1, [sp, #12]
--   814b4:	78617800 	ldrh	w0, [x0, x1, lsl #1]
--   814b8:	7100001f 	cmp	w0, #0x0
--   814bc:	54000161 	b.ne	814e8 <get_free_page+0x4c>  // b.any
--			mem_map[i] = 1;
--   814c0:	d0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   814c4:	91182000 	add	x0, x0, #0x608
--   814c8:	b9800fe1 	ldrsw	x1, [sp, #12]
--   814cc:	52800022 	mov	w2, #0x1                   	// #1
--   814d0:	78217802 	strh	w2, [x0, x1, lsl #1]
--			return LOW_MEMORY + i*PAGE_SIZE;
--   814d4:	b9400fe0 	ldr	w0, [sp, #12]
--   814d8:	11100000 	add	w0, w0, #0x400
--   814dc:	53144c00 	lsl	w0, w0, #12
--   814e0:	93407c00 	sxtw	x0, w0
--   814e4:	1400000a 	b	8150c <get_free_page+0x70>
--	for (int i = 0; i < PAGING_PAGES; i++){
--   814e8:	b9400fe0 	ldr	w0, [sp, #12]
--   814ec:	11000400 	add	w0, w0, #0x1
--   814f0:	b9000fe0 	str	w0, [sp, #12]
--   814f4:	b9400fe1 	ldr	w1, [sp, #12]
--   814f8:	529d7fe0 	mov	w0, #0xebff                	// #60415
--   814fc:	72a00060 	movk	w0, #0x3, lsl #16
--   81500:	6b00003f 	cmp	w1, w0
--   81504:	54fffd2d 	b.le	814a8 <get_free_page+0xc>
--		}
--	}
--	return 0;
--   81508:	d2800000 	mov	x0, #0x0                   	// #0
--}
--   8150c:	910043ff 	add	sp, sp, #0x10
--   81510:	d65f03c0 	ret
--
--0000000000081514 <free_page>:
--
--void free_page(unsigned long p){
--   81514:	d10043ff 	sub	sp, sp, #0x10
--   81518:	f90007e0 	str	x0, [sp, #8]
--	mem_map[(p - LOW_MEMORY) / PAGE_SIZE] = 0;
--   8151c:	f94007e0 	ldr	x0, [sp, #8]
--   81520:	d1500000 	sub	x0, x0, #0x400, lsl #12
--   81524:	d34cfc01 	lsr	x1, x0, #12
--   81528:	d0000000 	adrp	x0, 83000 <irq_invalid_el1t+0x24>
--   8152c:	91182000 	add	x0, x0, #0x608
--   81530:	7821781f 	strh	wzr, [x0, x1, lsl #1]
--}
--   81534:	d503201f 	nop
--   81538:	910043ff 	add	sp, sp, #0x10
--   8153c:	d65f03c0 	ret
--
--0000000000081540 <uart_send>:
--#include "utils.h"
--#include "peripherals/mini_uart.h"
--#include "peripherals/gpio.h"
--
--void uart_send ( char c )
--{
--   81540:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   81544:	910003fd 	mov	x29, sp
--   81548:	39007fe0 	strb	w0, [sp, #31]
--	while(1) {
--		if(get32(AUX_MU_LSR_REG)&0x20) 
--   8154c:	d28a0a80 	mov	x0, #0x5054                	// #20564
--   81550:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   81554:	94000822 	bl	835dc <get32>
--   81558:	121b0000 	and	w0, w0, #0x20
--   8155c:	7100001f 	cmp	w0, #0x0
--   81560:	54000041 	b.ne	81568 <uart_send+0x28>  // b.any
--   81564:	17fffffa 	b	8154c <uart_send+0xc>
--			break;
--   81568:	d503201f 	nop
--	}
--	put32(AUX_MU_IO_REG,c);
--   8156c:	39407fe0 	ldrb	w0, [sp, #31]
--   81570:	2a0003e1 	mov	w1, w0
--   81574:	d28a0800 	mov	x0, #0x5040                	// #20544
--   81578:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   8157c:	94000816 	bl	835d4 <put32>
--}
--   81580:	d503201f 	nop
--   81584:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   81588:	d65f03c0 	ret
--
--000000000008158c <uart_recv>:
--
--char uart_recv ( void )
--{
--   8158c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
--   81590:	910003fd 	mov	x29, sp
--	while(1) {
--		if(get32(AUX_MU_LSR_REG)&0x01) 
--   81594:	d28a0a80 	mov	x0, #0x5054                	// #20564
--   81598:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   8159c:	94000810 	bl	835dc <get32>
--   815a0:	12000000 	and	w0, w0, #0x1
--   815a4:	7100001f 	cmp	w0, #0x0
--   815a8:	54000041 	b.ne	815b0 <uart_recv+0x24>  // b.any
--   815ac:	17fffffa 	b	81594 <uart_recv+0x8>
--			break;
--   815b0:	d503201f 	nop
--	}
--	return(get32(AUX_MU_IO_REG)&0xFF);
--   815b4:	d28a0800 	mov	x0, #0x5040                	// #20544
--   815b8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   815bc:	94000808 	bl	835dc <get32>
--   815c0:	12001c00 	and	w0, w0, #0xff
--}
--   815c4:	a8c17bfd 	ldp	x29, x30, [sp], #16
--   815c8:	d65f03c0 	ret
--
--00000000000815cc <uart_send_string>:
--
--void uart_send_string(char* str)
--{
--   815cc:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
--   815d0:	910003fd 	mov	x29, sp
--   815d4:	f9000fe0 	str	x0, [sp, #24]
--	for (int i = 0; str[i] != '\0'; i ++) {
--   815d8:	b9002fff 	str	wzr, [sp, #44]
--   815dc:	14000009 	b	81600 <uart_send_string+0x34>
--		uart_send((char)str[i]);
--   815e0:	b9802fe0 	ldrsw	x0, [sp, #44]
--   815e4:	f9400fe1 	ldr	x1, [sp, #24]
--   815e8:	8b000020 	add	x0, x1, x0
--   815ec:	39400000 	ldrb	w0, [x0]
--   815f0:	97ffffd4 	bl	81540 <uart_send>
--	for (int i = 0; str[i] != '\0'; i ++) {
--   815f4:	b9402fe0 	ldr	w0, [sp, #44]
--   815f8:	11000400 	add	w0, w0, #0x1
--   815fc:	b9002fe0 	str	w0, [sp, #44]
--   81600:	b9802fe0 	ldrsw	x0, [sp, #44]
--   81604:	f9400fe1 	ldr	x1, [sp, #24]
--   81608:	8b000020 	add	x0, x1, x0
--   8160c:	39400000 	ldrb	w0, [x0]
--   81610:	7100001f 	cmp	w0, #0x0
--   81614:	54fffe61 	b.ne	815e0 <uart_send_string+0x14>  // b.any
--	}
--}
--   81618:	d503201f 	nop
--   8161c:	d503201f 	nop
--   81620:	a8c37bfd 	ldp	x29, x30, [sp], #48
--   81624:	d65f03c0 	ret
--
--0000000000081628 <uart_init>:
--
--void uart_init ( void )
--{
--   81628:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   8162c:	910003fd 	mov	x29, sp
--	unsigned int selector;
--
--	selector = get32(GPFSEL1);
--   81630:	d2800080 	mov	x0, #0x4                   	// #4
--   81634:	f2a7e400 	movk	x0, #0x3f20, lsl #16
--   81638:	940007e9 	bl	835dc <get32>
--   8163c:	b9001fe0 	str	w0, [sp, #28]
--	selector &= ~(7<<12);                   // clean gpio14
--   81640:	b9401fe0 	ldr	w0, [sp, #28]
--   81644:	12117000 	and	w0, w0, #0xffff8fff
--   81648:	b9001fe0 	str	w0, [sp, #28]
--	selector |= 2<<12;                      // set alt5 for gpio14
--   8164c:	b9401fe0 	ldr	w0, [sp, #28]
--   81650:	32130000 	orr	w0, w0, #0x2000
--   81654:	b9001fe0 	str	w0, [sp, #28]
--	selector &= ~(7<<15);                   // clean gpio15
--   81658:	b9401fe0 	ldr	w0, [sp, #28]
--   8165c:	120e7000 	and	w0, w0, #0xfffc7fff
--   81660:	b9001fe0 	str	w0, [sp, #28]
--	selector |= 2<<15;                      // set alt5 for gpio15
--   81664:	b9401fe0 	ldr	w0, [sp, #28]
--   81668:	32100000 	orr	w0, w0, #0x10000
--   8166c:	b9001fe0 	str	w0, [sp, #28]
--	put32(GPFSEL1,selector);
--   81670:	b9401fe1 	ldr	w1, [sp, #28]
--   81674:	d2800080 	mov	x0, #0x4                   	// #4
--   81678:	f2a7e400 	movk	x0, #0x3f20, lsl #16
--   8167c:	940007d6 	bl	835d4 <put32>
--
--	put32(GPPUD,0);
--   81680:	52800001 	mov	w1, #0x0                   	// #0
--   81684:	d2801280 	mov	x0, #0x94                  	// #148
--   81688:	f2a7e400 	movk	x0, #0x3f20, lsl #16
--   8168c:	940007d2 	bl	835d4 <put32>
--	delay(150);
--   81690:	d28012c0 	mov	x0, #0x96                  	// #150
--   81694:	940007d4 	bl	835e4 <delay>
--	put32(GPPUDCLK0,(1<<14)|(1<<15));
--   81698:	52980001 	mov	w1, #0xc000                	// #49152
--   8169c:	d2801300 	mov	x0, #0x98                  	// #152
--   816a0:	f2a7e400 	movk	x0, #0x3f20, lsl #16
--   816a4:	940007cc 	bl	835d4 <put32>
--	delay(150);
--   816a8:	d28012c0 	mov	x0, #0x96                  	// #150
--   816ac:	940007ce 	bl	835e4 <delay>
--	put32(GPPUDCLK0,0);
--   816b0:	52800001 	mov	w1, #0x0                   	// #0
--   816b4:	d2801300 	mov	x0, #0x98                  	// #152
--   816b8:	f2a7e400 	movk	x0, #0x3f20, lsl #16
--   816bc:	940007c6 	bl	835d4 <put32>
--
--	put32(AUX_ENABLES,1);                   //Enable mini uart (this also enables access to it registers)
--   816c0:	52800021 	mov	w1, #0x1                   	// #1
--   816c4:	d28a0080 	mov	x0, #0x5004                	// #20484
--   816c8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   816cc:	940007c2 	bl	835d4 <put32>
--	put32(AUX_MU_CNTL_REG,0);               //Disable auto flow control and disable receiver and transmitter (for now)
--   816d0:	52800001 	mov	w1, #0x0                   	// #0
--   816d4:	d28a0c00 	mov	x0, #0x5060                	// #20576
--   816d8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   816dc:	940007be 	bl	835d4 <put32>
--	put32(AUX_MU_IER_REG,0);                //Disable receive and transmit interrupts
--   816e0:	52800001 	mov	w1, #0x0                   	// #0
--   816e4:	d28a0880 	mov	x0, #0x5044                	// #20548
--   816e8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   816ec:	940007ba 	bl	835d4 <put32>
--	put32(AUX_MU_LCR_REG,3);                //Enable 8 bit mode
--   816f0:	52800061 	mov	w1, #0x3                   	// #3
--   816f4:	d28a0980 	mov	x0, #0x504c                	// #20556
--   816f8:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   816fc:	940007b6 	bl	835d4 <put32>
--	put32(AUX_MU_MCR_REG,0);                //Set RTS line to be always high
--   81700:	52800001 	mov	w1, #0x0                   	// #0
--   81704:	d28a0a00 	mov	x0, #0x5050                	// #20560
--   81708:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   8170c:	940007b2 	bl	835d4 <put32>
--	put32(AUX_MU_BAUD_REG,270);             //Set baud rate to 115200
--   81710:	528021c1 	mov	w1, #0x10e                 	// #270
--   81714:	d28a0d00 	mov	x0, #0x5068                	// #20584
--   81718:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   8171c:	940007ae 	bl	835d4 <put32>
--
--	put32(AUX_MU_CNTL_REG,3);               //Finally, enable transmitter and receiver
--   81720:	52800061 	mov	w1, #0x3                   	// #3
--   81724:	d28a0c00 	mov	x0, #0x5060                	// #20576
--   81728:	f2a7e420 	movk	x0, #0x3f21, lsl #16
--   8172c:	940007aa 	bl	835d4 <put32>
--}
--   81730:	d503201f 	nop
--   81734:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   81738:	d65f03c0 	ret
--
--000000000008173c <putc>:
--
--
--// This function is required by printf function
--void putc ( void* p, char c)
--{
--   8173c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   81740:	910003fd 	mov	x29, sp
--   81744:	f9000fe0 	str	x0, [sp, #24]
--   81748:	39005fe1 	strb	w1, [sp, #23]
--	uart_send(c);
--   8174c:	39405fe0 	ldrb	w0, [sp, #23]
--   81750:	97ffff7c 	bl	81540 <uart_send>
--}
--   81754:	d503201f 	nop
--   81758:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   8175c:	d65f03c0 	ret
--
--0000000000081760 <_schedule>:
--struct task_struct * task[NR_TASKS] = {&(init_task), };
--int nr_tasks = 1;
--//int delay_sec = 0;
--
--void _schedule(void)
--{
--   81760:	d10083ff 	sub	sp, sp, #0x20
--	int next, c;
--	struct task_struct * p;
--	while (1) {
--		c = -1;	// the maximum counter found so far
--   81764:	12800000 	mov	w0, #0xffffffff            	// #-1
--   81768:	b9001fe0 	str	w0, [sp, #28]
--		next = 0;
--   8176c:	b90013ff 	str	wzr, [sp, #16]
--		/* Iterates over all tasks and tries to find a task in 
--		TASK_RUNNING state with the maximum counter. If such 
--		a task is found, we immediately break from the while loop 
--		and switch to this task. */
--
--		for (int i = 0; i < NR_TASKS; i++){
--   81770:	b9001bff 	str	wzr, [sp, #24]
--   81774:	1400001a 	b	817dc <_schedule+0x7c>
--			p = task[i];
--   81778:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8177c:	913dc000 	add	x0, x0, #0xf70
--   81780:	b9801be1 	ldrsw	x1, [sp, #24]
--   81784:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   81788:	f90007e0 	str	x0, [sp, #8]
--			if (p && p->state == TASK_RUNNING && p->counter > c) {
--   8178c:	f94007e0 	ldr	x0, [sp, #8]
--   81790:	f100001f 	cmp	x0, #0x0
--   81794:	540001e0 	b.eq	817d0 <_schedule+0x70>  // b.none
--   81798:	f94007e0 	ldr	x0, [sp, #8]
--   8179c:	f9403400 	ldr	x0, [x0, #104]
--   817a0:	f100001f 	cmp	x0, #0x0
--   817a4:	54000161 	b.ne	817d0 <_schedule+0x70>  // b.any
--   817a8:	f94007e0 	ldr	x0, [sp, #8]
--   817ac:	f9403801 	ldr	x1, [x0, #112]
--   817b0:	b9801fe0 	ldrsw	x0, [sp, #28]
--   817b4:	eb00003f 	cmp	x1, x0
--   817b8:	540000cd 	b.le	817d0 <_schedule+0x70>
--				c = p->counter;
--   817bc:	f94007e0 	ldr	x0, [sp, #8]
--   817c0:	f9403800 	ldr	x0, [x0, #112]
--   817c4:	b9001fe0 	str	w0, [sp, #28]
--				next = i;
--   817c8:	b9401be0 	ldr	w0, [sp, #24]
--   817cc:	b90013e0 	str	w0, [sp, #16]
--		for (int i = 0; i < NR_TASKS; i++){
--   817d0:	b9401be0 	ldr	w0, [sp, #24]
--   817d4:	11000400 	add	w0, w0, #0x1
--   817d8:	b9001be0 	str	w0, [sp, #24]
--   817dc:	b9401be0 	ldr	w0, [sp, #24]
--   817e0:	7100fc1f 	cmp	w0, #0x3f
--   817e4:	54fffcad 	b.le	81778 <_schedule+0x18>
--
--		/* If no such task is found, this is either because i) no 
--		task is in TASK_RUNNING state or ii) all such tasks have 0 counters.
--		in our current implemenation which misses TASK_WAIT, only condition ii) is possible. 
--		Hence, we recharge counters. Bump counters for all tasks once. */
--		for (int i = 0; i < NR_TASKS; i++) {
--   817e8:	b90017ff 	str	wzr, [sp, #20]
--   817ec:	14000014 	b	8183c <_schedule+0xdc>
--			p = task[i];
--   817f0:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   817f4:	913dc000 	add	x0, x0, #0xf70
--   817f8:	b98017e1 	ldrsw	x1, [sp, #20]
--   817fc:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   81800:	f90007e0 	str	x0, [sp, #8]
--			if (p) {
--   81804:	f94007e0 	ldr	x0, [sp, #8]
--   81808:	f100001f 	cmp	x0, #0x0
--   8180c:	54000120 	b.eq	81830 <_schedule+0xd0>  // b.none
--				p->counter = (p->counter >> 1) + p->priority; // The increment depends on a task's priority.
--   81810:	f94007e0 	ldr	x0, [sp, #8]
--   81814:	f9403800 	ldr	x0, [x0, #112]
--   81818:	9341fc01 	asr	x1, x0, #1
--   8181c:	f94007e0 	ldr	x0, [sp, #8]
--   81820:	f9403c00 	ldr	x0, [x0, #120]
--   81824:	8b000021 	add	x1, x1, x0
--   81828:	f94007e0 	ldr	x0, [sp, #8]
--   8182c:	f9003801 	str	x1, [x0, #112]
--		for (int i = 0; i < NR_TASKS; i++) {
--   81830:	b94017e0 	ldr	w0, [sp, #20]
--   81834:	11000400 	add	w0, w0, #0x1
--   81838:	b90017e0 	str	w0, [sp, #20]
--   8183c:	b94017e0 	ldr	w0, [sp, #20]
--   81840:	7100fc1f 	cmp	w0, #0x3f
--   81844:	54fffd6d 	b.le	817f0 <_schedule+0x90>
--		c = -1;	// the maximum counter found so far
--   81848:	17ffffc7 	b	81764 <_schedule+0x4>
--
--000000000008184c <schedule>:
--	}
--	switch_to(task[next]);
--}
--
--void schedule(void)
--{
--   8184c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
--   81850:	910003fd 	mov	x29, sp
--	current->counter = 0;
--   81854:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81858:	913da000 	add	x0, x0, #0xf68
--   8185c:	f9400000 	ldr	x0, [x0]
--   81860:	f900381f 	str	xzr, [x0, #112]
--	_schedule();
--   81864:	97ffffbf 	bl	81760 <_schedule>
--}
--   81868:	d503201f 	nop
--   8186c:	a8c17bfd 	ldp	x29, x30, [sp], #16
--   81870:	d65f03c0 	ret
--
--0000000000081874 <switch_to>:
--
--void switch_to(struct task_struct * next) 
--{
--   81874:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
--   81878:	910003fd 	mov	x29, sp
--   8187c:	f9000fe0 	str	x0, [sp, #24]
--	if (current == next) 
--   81880:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81884:	913da000 	add	x0, x0, #0xf68
--   81888:	f9400000 	ldr	x0, [x0]
--   8188c:	f9400fe1 	ldr	x1, [sp, #24]
--   81890:	eb00003f 	cmp	x1, x0
--   81894:	540001a0 	b.eq	818c8 <switch_to+0x54>  // b.none
--		return;
--	struct task_struct * prev = current;
--   81898:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8189c:	913da000 	add	x0, x0, #0xf68
--   818a0:	f9400000 	ldr	x0, [x0]
--   818a4:	f90017e0 	str	x0, [sp, #40]
--	current = next;
--   818a8:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   818ac:	913da000 	add	x0, x0, #0xf68
--   818b0:	f9400fe1 	ldr	x1, [sp, #24]
--   818b4:	f9000001 	str	x1, [x0]
--	cpu_switch_to(prev, next);
--   818b8:	f9400fe1 	ldr	x1, [sp, #24]
--   818bc:	f94017e0 	ldr	x0, [sp, #40]
--   818c0:	9400072e 	bl	83578 <cpu_switch_to>
--   818c4:	14000002 	b	818cc <switch_to+0x58>
--		return;
--   818c8:	d503201f 	nop
--}
--   818cc:	a8c37bfd 	ldp	x29, x30, [sp], #48
--   818d0:	d65f03c0 	ret
--
--00000000000818d4 <schedule_tail>:
--
--void schedule_tail(void) {
--	/* nothing */
--}
--   818d4:	d503201f 	nop
--   818d8:	d65f03c0 	ret
--
--00000000000818dc <read_cntfrq>:
--	Recommended.
--*/
--
--// xzl: CNTFRQ_EL0 reports the frequency of the system count
--static unsigned int read_cntfrq(void)
--{
--   818dc:	d10043ff 	sub	sp, sp, #0x10
--	unsigned int val;
--	asm volatile ("mrs %0, cntfrq_el0" : "=r" (val));
--   818e0:	d53be000 	mrs	x0, cntfrq_el0
--   818e4:	b9000fe0 	str	w0, [sp, #12]
--  	return val;
--   818e8:	b9400fe0 	ldr	w0, [sp, #12]
--}
--   818ec:	910043ff 	add	sp, sp, #0x10
--   818f0:	d65f03c0 	ret
--
--00000000000818f4 <generic_timer_init>:
--
--void generic_timer_init ( void )
--{
--   818f4:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   818f8:	910003fd 	mov	x29, sp
--	unsigned int freq  = read_cntfrq();
--   818fc:	97fffff8 	bl	818dc <read_cntfrq>
--   81900:	b9001fe0 	str	w0, [sp, #28]
--	printf("System count freq (CNTFRQ) is: %u\n", freq);
--   81904:	b9401fe1 	ldr	w1, [sp, #28]
--   81908:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8190c:	91046000 	add	x0, x0, #0x118
--   81910:	940002b5 	bl	823e4 <tfp_printf>
--
--	printf("interval is set to: %u\n", interval);
--   81914:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81918:	911af000 	add	x0, x0, #0x6bc
--   8191c:	b9400000 	ldr	w0, [x0]
--   81920:	2a0003e1 	mov	w1, w0
--   81924:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81928:	91050000 	add	x0, x0, #0x140
--   8192c:	940002ae 	bl	823e4 <tfp_printf>
--	gen_timer_init();
--   81930:	94000332 	bl	825f8 <gen_timer_init>
--	gen_timer_reset(interval);
--   81934:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81938:	911af000 	add	x0, x0, #0x6bc
--   8193c:	b9400000 	ldr	w0, [x0]
--   81940:	94000331 	bl	82604 <gen_timer_reset>
--}
--   81944:	d503201f 	nop
--   81948:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   8194c:	d65f03c0 	ret
--
--0000000000081950 <handle_generic_timer_irq>:
--
--extern struct task_struct * task[64];
--void handle_generic_timer_irq( void ) 
--{
--   81950:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   81954:	910003fd 	mov	x29, sp
--	printf("Timer interrupt received. next in %u ticks\n\r", interval);
--   81958:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8195c:	911af000 	add	x0, x0, #0x6bc
--   81960:	b9400000 	ldr	w0, [x0]
--   81964:	2a0003e1 	mov	w1, w0
--   81968:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   8196c:	91056000 	add	x0, x0, #0x158
--   81970:	9400029d 	bl	823e4 <tfp_printf>
--	gen_timer_reset(interval);
--   81974:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81978:	911af000 	add	x0, x0, #0x6bc
--   8197c:	b9400000 	ldr	w0, [x0]
--   81980:	94000321 	bl	82604 <gen_timer_reset>
--	for (int i=1; i<10; i++){
--   81984:	52800020 	mov	w0, #0x1                   	// #1
--   81988:	b9001fe0 	str	w0, [sp, #28]
--   8198c:	14000028 	b	81a2c <handle_generic_timer_irq+0xdc>
--		//task_struct p = task[i];
--		if (task[i] && task[i]->delay_sec > 0) {
--   81990:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81994:	f940c800 	ldr	x0, [x0, #400]
--   81998:	b9801fe1 	ldrsw	x1, [sp, #28]
--   8199c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   819a0:	f100001f 	cmp	x0, #0x0
--   819a4:	54000260 	b.eq	819f0 <handle_generic_timer_irq+0xa0>  // b.none
--   819a8:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   819ac:	f940c800 	ldr	x0, [x0, #400]
--   819b0:	b9801fe1 	ldrsw	x1, [sp, #28]
--   819b4:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   819b8:	f9404000 	ldr	x0, [x0, #128]
--   819bc:	f100001f 	cmp	x0, #0x0
--   819c0:	5400018d 	b.le	819f0 <handle_generic_timer_irq+0xa0>
--			task[i]->delay_sec = task[i]->delay_sec -1;
--   819c4:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   819c8:	f940c800 	ldr	x0, [x0, #400]
--   819cc:	b9801fe1 	ldrsw	x1, [sp, #28]
--   819d0:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   819d4:	f9404001 	ldr	x1, [x0, #128]
--   819d8:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   819dc:	f940c800 	ldr	x0, [x0, #400]
--   819e0:	b9801fe2 	ldrsw	x2, [sp, #28]
--   819e4:	f8627800 	ldr	x0, [x0, x2, lsl #3]
--   819e8:	d1000421 	sub	x1, x1, #0x1
--   819ec:	f9004001 	str	x1, [x0, #128]
--		}
--		if (task[i]->delay_sec <= 0){
--   819f0:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   819f4:	f940c800 	ldr	x0, [x0, #400]
--   819f8:	b9801fe1 	ldrsw	x1, [sp, #28]
--   819fc:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   81a00:	f9404000 	ldr	x0, [x0, #128]
--   81a04:	f100001f 	cmp	x0, #0x0
--   81a08:	540000cc 	b.gt	81a20 <handle_generic_timer_irq+0xd0>
--			task[i]->state = 0;
--   81a0c:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81a10:	f940c800 	ldr	x0, [x0, #400]
--   81a14:	b9801fe1 	ldrsw	x1, [sp, #28]
--   81a18:	f8617800 	ldr	x0, [x0, x1, lsl #3]
--   81a1c:	f900341f 	str	xzr, [x0, #104]
--	for (int i=1; i<10; i++){
--   81a20:	b9401fe0 	ldr	w0, [sp, #28]
--   81a24:	11000400 	add	w0, w0, #0x1
--   81a28:	b9001fe0 	str	w0, [sp, #28]
--   81a2c:	b9401fe0 	ldr	w0, [sp, #28]
--   81a30:	7100241f 	cmp	w0, #0x9
--   81a34:	54fffaed 	b.le	81990 <handle_generic_timer_irq+0x40>
--		}
--	}
--}
--   81a38:	d503201f 	nop
--   81a3c:	d503201f 	nop
--   81a40:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   81a44:	d65f03c0 	ret
--
--0000000000081a48 <timer_init>:
--	https://fxlin.github.io/p1-kernel/exp3/rpi-os/#fyi-other-timers-on-rpi3
--*/
--unsigned int curVal = 0;
--
--void timer_init ( void )
--{
--   81a48:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
--   81a4c:	910003fd 	mov	x29, sp
--	curVal = get32(TIMER_CLO);
--   81a50:	d2860080 	mov	x0, #0x3004                	// #12292
--   81a54:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   81a58:	940006e1 	bl	835dc <get32>
--   81a5c:	2a0003e1 	mov	w1, w0
--   81a60:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81a64:	91382000 	add	x0, x0, #0xe08
--   81a68:	b9000001 	str	w1, [x0]
--	curVal += interval;
--   81a6c:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81a70:	91382000 	add	x0, x0, #0xe08
--   81a74:	b9400001 	ldr	w1, [x0]
--   81a78:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81a7c:	911af000 	add	x0, x0, #0x6bc
--   81a80:	b9400000 	ldr	w0, [x0]
--   81a84:	0b000021 	add	w1, w1, w0
--   81a88:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81a8c:	91382000 	add	x0, x0, #0xe08
--   81a90:	b9000001 	str	w1, [x0]
--	put32(TIMER_C1, curVal);
--   81a94:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81a98:	91382000 	add	x0, x0, #0xe08
--   81a9c:	b9400000 	ldr	w0, [x0]
--   81aa0:	2a0003e1 	mov	w1, w0
--   81aa4:	d2860200 	mov	x0, #0x3010                	// #12304
--   81aa8:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   81aac:	940006ca 	bl	835d4 <put32>
--}
--   81ab0:	d503201f 	nop
--   81ab4:	a8c17bfd 	ldp	x29, x30, [sp], #16
--   81ab8:	d65f03c0 	ret
--
--0000000000081abc <handle_timer_irq>:
--
--void handle_timer_irq( void ) 
--{
--   81abc:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
--   81ac0:	910003fd 	mov	x29, sp
--	curVal += interval;
--   81ac4:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81ac8:	91382000 	add	x0, x0, #0xe08
--   81acc:	b9400001 	ldr	w1, [x0]
--   81ad0:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81ad4:	911af000 	add	x0, x0, #0x6bc
--   81ad8:	b9400000 	ldr	w0, [x0]
--   81adc:	0b000021 	add	w1, w1, w0
--   81ae0:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81ae4:	91382000 	add	x0, x0, #0xe08
--   81ae8:	b9000001 	str	w1, [x0]
--	put32(TIMER_C1, curVal);
--   81aec:	f00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   81af0:	91382000 	add	x0, x0, #0xe08
--   81af4:	b9400000 	ldr	w0, [x0]
--   81af8:	2a0003e1 	mov	w1, w0
--   81afc:	d2860200 	mov	x0, #0x3010                	// #12304
--   81b00:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   81b04:	940006b4 	bl	835d4 <put32>
--	put32(TIMER_CS, TIMER_CS_M1);
--   81b08:	52800041 	mov	w1, #0x2                   	// #2
--   81b0c:	d2860000 	mov	x0, #0x3000                	// #12288
--   81b10:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   81b14:	940006b0 	bl	835d4 <put32>
--	printf("Timer interrupt received\n\r");
--   81b18:	d0000bc0 	adrp	x0, 1fb000 <bss_end+0xfa150>
--   81b1c:	91062000 	add	x0, x0, #0x188
--   81b20:	94000231 	bl	823e4 <tfp_printf>
--}
--   81b24:	d503201f 	nop
--   81b28:	a8c17bfd 	ldp	x29, x30, [sp], #16
--   81b2c:	d65f03c0 	ret
--
--0000000000081b30 <copy_process>:
--#include "mm.h"
--#include "sched.h"
--#include "entry.h"
--
--int copy_process(unsigned long fn, unsigned long arg)
--{
--   81b30:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
--   81b34:	910003fd 	mov	x29, sp
--   81b38:	f9000fe0 	str	x0, [sp, #24]
--   81b3c:	f9000be1 	str	x1, [sp, #16]
--//	preempt_disable();
--	struct task_struct *p;
--
--	p = (struct task_struct *) get_free_page();
--   81b40:	97fffe57 	bl	8149c <get_free_page>
--   81b44:	f90017e0 	str	x0, [sp, #40]
--	if (!p)
--   81b48:	f94017e0 	ldr	x0, [sp, #40]
--   81b4c:	f100001f 	cmp	x0, #0x0
--   81b50:	54000061 	b.ne	81b5c <copy_process+0x2c>  // b.any
--		return 1;
--   81b54:	52800020 	mov	w0, #0x1                   	// #1
--   81b58:	1400002b 	b	81c04 <copy_process+0xd4>
--	p->priority = current->priority;
--   81b5c:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81b60:	f940c000 	ldr	x0, [x0, #384]
--   81b64:	f9400000 	ldr	x0, [x0]
--   81b68:	f9403c01 	ldr	x1, [x0, #120]
--   81b6c:	f94017e0 	ldr	x0, [sp, #40]
--   81b70:	f9003c01 	str	x1, [x0, #120]
--	p->state = TASK_RUNNING;
--   81b74:	f94017e0 	ldr	x0, [sp, #40]
--   81b78:	f900341f 	str	xzr, [x0, #104]
--	p->counter = p->priority;
--   81b7c:	f94017e0 	ldr	x0, [sp, #40]
--   81b80:	f9403c01 	ldr	x1, [x0, #120]
--   81b84:	f94017e0 	ldr	x0, [sp, #40]
--   81b88:	f9003801 	str	x1, [x0, #112]
--//	p->preempt_count = 1; //disable preemtion until schedule_tail
--	p->delay_sec = 0;
--   81b8c:	f94017e0 	ldr	x0, [sp, #40]
--   81b90:	f900401f 	str	xzr, [x0, #128]
--	p->cpu_context.x19 = fn;
--   81b94:	f94017e0 	ldr	x0, [sp, #40]
--   81b98:	f9400fe1 	ldr	x1, [sp, #24]
--   81b9c:	f9000001 	str	x1, [x0]
--	p->cpu_context.x20 = arg;
--   81ba0:	f94017e0 	ldr	x0, [sp, #40]
--   81ba4:	f9400be1 	ldr	x1, [sp, #16]
--   81ba8:	f9000401 	str	x1, [x0, #8]
--	p->cpu_context.pc = (unsigned long)ret_from_fork;
--   81bac:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81bb0:	f940d001 	ldr	x1, [x0, #416]
--   81bb4:	f94017e0 	ldr	x0, [sp, #40]
--   81bb8:	f9003001 	str	x1, [x0, #96]
--	p->cpu_context.sp = (unsigned long)p + THREAD_SIZE;
--   81bbc:	f94017e0 	ldr	x0, [sp, #40]
--   81bc0:	91400401 	add	x1, x0, #0x1, lsl #12
--   81bc4:	f94017e0 	ldr	x0, [sp, #40]
--   81bc8:	f9002c01 	str	x1, [x0, #88]
--	int pid = nr_tasks++;
--   81bcc:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81bd0:	f940c400 	ldr	x0, [x0, #392]
--   81bd4:	b9400000 	ldr	w0, [x0]
--   81bd8:	11000402 	add	w2, w0, #0x1
--   81bdc:	f0000bc1 	adrp	x1, 1fc000 <task+0x90>
--   81be0:	f940c421 	ldr	x1, [x1, #392]
--   81be4:	b9000022 	str	w2, [x1]
--   81be8:	b90027e0 	str	w0, [sp, #36]
--	task[pid] = p;	
--   81bec:	f0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   81bf0:	f940c800 	ldr	x0, [x0, #400]
--   81bf4:	b98027e1 	ldrsw	x1, [sp, #36]
--   81bf8:	f94017e2 	ldr	x2, [sp, #40]
--   81bfc:	f8217802 	str	x2, [x0, x1, lsl #3]
--//	preempt_enable();
--	return 0;
--   81c00:	52800000 	mov	w0, #0x0                   	// #0
--}
--   81c04:	a8c37bfd 	ldp	x29, x30, [sp], #48
--   81c08:	d65f03c0 	ret
--
--0000000000081c0c <ui2a>:
--    }
--
--#endif
--
--static void ui2a(unsigned int num, unsigned int base, int uc,char * bf)
--    {
--   81c0c:	d100c3ff 	sub	sp, sp, #0x30
--   81c10:	b9001fe0 	str	w0, [sp, #28]
--   81c14:	b9001be1 	str	w1, [sp, #24]
--   81c18:	b90017e2 	str	w2, [sp, #20]
--   81c1c:	f90007e3 	str	x3, [sp, #8]
--    int n=0;
--   81c20:	b9002fff 	str	wzr, [sp, #44]
--    unsigned int d=1;
--   81c24:	52800020 	mov	w0, #0x1                   	// #1
--   81c28:	b9002be0 	str	w0, [sp, #40]
--    while (num/d >= base)
--   81c2c:	14000005 	b	81c40 <ui2a+0x34>
--        d*=base;
--   81c30:	b9402be1 	ldr	w1, [sp, #40]
--   81c34:	b9401be0 	ldr	w0, [sp, #24]
--   81c38:	1b007c20 	mul	w0, w1, w0
--   81c3c:	b9002be0 	str	w0, [sp, #40]
--    while (num/d >= base)
--   81c40:	b9401fe1 	ldr	w1, [sp, #28]
--   81c44:	b9402be0 	ldr	w0, [sp, #40]
--   81c48:	1ac00820 	udiv	w0, w1, w0
--   81c4c:	b9401be1 	ldr	w1, [sp, #24]
--   81c50:	6b00003f 	cmp	w1, w0
--   81c54:	54fffee9 	b.ls	81c30 <ui2a+0x24>  // b.plast
--    while (d!=0) {
--   81c58:	1400002f 	b	81d14 <ui2a+0x108>
--        int dgt = num / d;
--   81c5c:	b9401fe1 	ldr	w1, [sp, #28]
--   81c60:	b9402be0 	ldr	w0, [sp, #40]
--   81c64:	1ac00820 	udiv	w0, w1, w0
--   81c68:	b90027e0 	str	w0, [sp, #36]
--        num%= d;
--   81c6c:	b9401fe0 	ldr	w0, [sp, #28]
--   81c70:	b9402be1 	ldr	w1, [sp, #40]
--   81c74:	1ac10802 	udiv	w2, w0, w1
--   81c78:	b9402be1 	ldr	w1, [sp, #40]
--   81c7c:	1b017c41 	mul	w1, w2, w1
--   81c80:	4b010000 	sub	w0, w0, w1
--   81c84:	b9001fe0 	str	w0, [sp, #28]
--        d/=base;
--   81c88:	b9402be1 	ldr	w1, [sp, #40]
--   81c8c:	b9401be0 	ldr	w0, [sp, #24]
--   81c90:	1ac00820 	udiv	w0, w1, w0
--   81c94:	b9002be0 	str	w0, [sp, #40]
--        if (n || dgt>0 || d==0) {
--   81c98:	b9402fe0 	ldr	w0, [sp, #44]
--   81c9c:	7100001f 	cmp	w0, #0x0
--   81ca0:	540000e1 	b.ne	81cbc <ui2a+0xb0>  // b.any
--   81ca4:	b94027e0 	ldr	w0, [sp, #36]
--   81ca8:	7100001f 	cmp	w0, #0x0
--   81cac:	5400008c 	b.gt	81cbc <ui2a+0xb0>
--   81cb0:	b9402be0 	ldr	w0, [sp, #40]
--   81cb4:	7100001f 	cmp	w0, #0x0
--   81cb8:	540002e1 	b.ne	81d14 <ui2a+0x108>  // b.any
--            *bf++ = dgt+(dgt<10 ? '0' : (uc ? 'A' : 'a')-10);
--   81cbc:	b94027e0 	ldr	w0, [sp, #36]
--   81cc0:	7100241f 	cmp	w0, #0x9
--   81cc4:	5400010d 	b.le	81ce4 <ui2a+0xd8>
--   81cc8:	b94017e0 	ldr	w0, [sp, #20]
--   81ccc:	7100001f 	cmp	w0, #0x0
--   81cd0:	54000060 	b.eq	81cdc <ui2a+0xd0>  // b.none
--   81cd4:	528006e0 	mov	w0, #0x37                  	// #55
--   81cd8:	14000004 	b	81ce8 <ui2a+0xdc>
--   81cdc:	52800ae0 	mov	w0, #0x57                  	// #87
--   81ce0:	14000002 	b	81ce8 <ui2a+0xdc>
--   81ce4:	52800600 	mov	w0, #0x30                  	// #48
--   81ce8:	b94027e1 	ldr	w1, [sp, #36]
--   81cec:	12001c22 	and	w2, w1, #0xff
--   81cf0:	f94007e1 	ldr	x1, [sp, #8]
--   81cf4:	91000423 	add	x3, x1, #0x1
--   81cf8:	f90007e3 	str	x3, [sp, #8]
--   81cfc:	0b020000 	add	w0, w0, w2
--   81d00:	12001c00 	and	w0, w0, #0xff
--   81d04:	39000020 	strb	w0, [x1]
--            ++n;
--   81d08:	b9402fe0 	ldr	w0, [sp, #44]
--   81d0c:	11000400 	add	w0, w0, #0x1
--   81d10:	b9002fe0 	str	w0, [sp, #44]
--    while (d!=0) {
--   81d14:	b9402be0 	ldr	w0, [sp, #40]
--   81d18:	7100001f 	cmp	w0, #0x0
--   81d1c:	54fffa01 	b.ne	81c5c <ui2a+0x50>  // b.any
--            }
--        }
--    *bf=0;
--   81d20:	f94007e0 	ldr	x0, [sp, #8]
--   81d24:	3900001f 	strb	wzr, [x0]
--    }
--   81d28:	d503201f 	nop
--   81d2c:	9100c3ff 	add	sp, sp, #0x30
--   81d30:	d65f03c0 	ret
--
--0000000000081d34 <i2a>:
--
--static void i2a (int num, char * bf)
--    {
--   81d34:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
--   81d38:	910003fd 	mov	x29, sp
--   81d3c:	b9001fe0 	str	w0, [sp, #28]
--   81d40:	f9000be1 	str	x1, [sp, #16]
--    if (num<0) {
--   81d44:	b9401fe0 	ldr	w0, [sp, #28]
--   81d48:	7100001f 	cmp	w0, #0x0
--   81d4c:	5400012a 	b.ge	81d70 <i2a+0x3c>  // b.tcont
--        num=-num;
--   81d50:	b9401fe0 	ldr	w0, [sp, #28]
--   81d54:	4b0003e0 	neg	w0, w0
--   81d58:	b9001fe0 	str	w0, [sp, #28]
--        *bf++ = '-';
--   81d5c:	f9400be0 	ldr	x0, [sp, #16]
--   81d60:	91000401 	add	x1, x0, #0x1
--   81d64:	f9000be1 	str	x1, [sp, #16]
--   81d68:	528005a1 	mov	w1, #0x2d                  	// #45
--   81d6c:	39000001 	strb	w1, [x0]
--        }
--    ui2a(num,10,0,bf);
--   81d70:	b9401fe0 	ldr	w0, [sp, #28]
--   81d74:	f9400be3 	ldr	x3, [sp, #16]
--   81d78:	52800002 	mov	w2, #0x0                   	// #0
--   81d7c:	52800141 	mov	w1, #0xa                   	// #10
--   81d80:	97ffffa3 	bl	81c0c <ui2a>
--    }
--   81d84:	d503201f 	nop
--   81d88:	a8c27bfd 	ldp	x29, x30, [sp], #32
--   81d8c:	d65f03c0 	ret
--
--0000000000081d90 <a2d>:
--
--static int a2d(char ch)
--    {
--   81d90:	d10043ff 	sub	sp, sp, #0x10
--   81d94:	39003fe0 	strb	w0, [sp, #15]
--    if (ch>='0' && ch<='9')
--   81d98:	39403fe0 	ldrb	w0, [sp, #15]
--   81d9c:	7100bc1f 	cmp	w0, #0x2f
--   81da0:	540000e9 	b.ls	81dbc <a2d+0x2c>  // b.plast
--   81da4:	39403fe0 	ldrb	w0, [sp, #15]
--   81da8:	7100e41f 	cmp	w0, #0x39
--   81dac:	54000088 	b.hi	81dbc <a2d+0x2c>  // b.pmore
--        return ch-'0';
--   81db0:	39403fe0 	ldrb	w0, [sp, #15]
--   81db4:	5100c000 	sub	w0, w0, #0x30
--   81db8:	14000014 	b	81e08 <a2d+0x78>
--    else if (ch>='a' && ch<='f')
--   81dbc:	39403fe0 	ldrb	w0, [sp, #15]
--   81dc0:	7101801f 	cmp	w0, #0x60
--   81dc4:	540000e9 	b.ls	81de0 <a2d+0x50>  // b.plast
--   81dc8:	39403fe0 	ldrb	w0, [sp, #15]
--   81dcc:	7101981f 	cmp	w0, #0x66
--   81dd0:	54000088 	b.hi	81de0 <a2d+0x50>  // b.pmore
--        return ch-'a'+10;
--   81dd4:	39403fe0 	ldrb	w0, [sp, #15]
--   81dd8:	51015c00 	sub	w0, w0, #0x57
--   81ddc:	1400000b 	b	81e08 <a2d+0x78>
--    else if (ch>='A' && ch<='F')
--   81de0:	39403fe0 	ldrb	w0, [sp, #15]
--   81de4:	7101001f 	cmp	w0, #0x40
--   81de8:	540000e9 	b.ls	81e04 <a2d+0x74>  // b.plast
--   81dec:	39403fe0 	ldrb	w0, [sp, #15]
--   81df0:	7101181f 	cmp	w0, #0x46
--   81df4:	54000088 	b.hi	81e04 <a2d+0x74>  // b.pmore
--        return ch-'A'+10;
--   81df8:	39403fe0 	ldrb	w0, [sp, #15]
--   81dfc:	5100dc00 	sub	w0, w0, #0x37
--   81e00:	14000002 	b	81e08 <a2d+0x78>
--    else return -1;
--   81e04:	12800000 	mov	w0, #0xffffffff            	// #-1
--    }
--   81e08:	910043ff 	add	sp, sp, #0x10
--   81e0c:	d65f03c0 	ret
--
--0000000000081e10 <a2i>:
--
--static char a2i(char ch, char** src,int base,int* nump)
--    {
--   81e10:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
--   81e14:	910003fd 	mov	x29, sp
--   81e18:	3900bfe0 	strb	w0, [sp, #47]
--   81e1c:	f90013e1 	str	x1, [sp, #32]
--   81e20:	b9002be2 	str	w2, [sp, #40]
--   81e24:	f9000fe3 	str	x3, [sp, #24]
--    char* p= *src;
--   81e28:	f94013e0 	ldr	x0, [sp, #32]
--   81e2c:	f9400000 	ldr	x0, [x0]
--   81e30:	f9001fe0 	str	x0, [sp, #56]
--    int num=0;
--   81e34:	b90037ff 	str	wzr, [sp, #52]
--    int digit;
--    while ((digit=a2d(ch))>=0) {
--   81e38:	14000010 	b	81e78 <a2i+0x68>
--        if (digit>base) break;
--   81e3c:	b94033e1 	ldr	w1, [sp, #48]
--   81e40:	b9402be0 	ldr	w0, [sp, #40]
--   81e44:	6b00003f 	cmp	w1, w0
--   81e48:	5400026c 	b.gt	81e94 <a2i+0x84>
--        num=num*base+digit;
--   81e4c:	b94037e1 	ldr	w1, [sp, #52]
--   81e50:	b9402be0 	ldr	w0, [sp, #40]
--   81e54:	1b007c20 	mul	w0, w1, w0
--   81e58:	b94033e1 	ldr	w1, [sp, #48]
--   81e5c:	0b000020 	add	w0, w1, w0
--   81e60:	b90037e0 	str	w0, [sp, #52]
--        ch=*p++;
--   81e64:	f9401fe0 	ldr	x0, [sp, #56]
--   81e68:	91000401 	add	x1, x0, #0x1
--   81e6c:	f9001fe1 	str	x1, [sp, #56]
--   81e70:	39400000 	ldrb	w0, [x0]
--   81e74:	3900bfe0 	strb	w0, [sp, #47]
--    while ((digit=a2d(ch))>=0) {
--   81e78:	3940bfe0 	ldrb	w0, [sp, #47]
--   81e7c:	97ffffc5 	bl	81d90 <a2d>
--   81e80:	b90033e0 	str	w0, [sp, #48]
--   81e84:	b94033e0 	ldr	w0, [sp, #48]
--   81e88:	7100001f 	cmp	w0, #0x0
--   81e8c:	54fffd8a 	b.ge	81e3c <a2i+0x2c>  // b.tcont
--   81e90:	14000002 	b	81e98 <a2i+0x88>
--        if (digit>base) break;
--   81e94:	d503201f 	nop
--        }
--    *src=p;
--   81e98:	f94013e0 	ldr	x0, [sp, #32]
--   81e9c:	f9401fe1 	ldr	x1, [sp, #56]
--   81ea0:	f9000001 	str	x1, [x0]
--    *nump=num;
--   81ea4:	f9400fe0 	ldr	x0, [sp, #24]
--   81ea8:	b94037e1 	ldr	w1, [sp, #52]
--   81eac:	b9000001 	str	w1, [x0]
--    return ch;
--   81eb0:	3940bfe0 	ldrb	w0, [sp, #47]
--    }
--   81eb4:	a8c47bfd 	ldp	x29, x30, [sp], #64
--   81eb8:	d65f03c0 	ret
--
--0000000000081ebc <putchw>:
--
--static void putchw(void* putp,putcf putf,int n, char z, char* bf)
--    {
--   81ebc:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
--   81ec0:	910003fd 	mov	x29, sp
--   81ec4:	f90017e0 	str	x0, [sp, #40]
--   81ec8:	f90013e1 	str	x1, [sp, #32]
--   81ecc:	b9001fe2 	str	w2, [sp, #28]
--   81ed0:	39006fe3 	strb	w3, [sp, #27]
--   81ed4:	f9000be4 	str	x4, [sp, #16]
--    char fc=z? '0' : ' ';
--   81ed8:	39406fe0 	ldrb	w0, [sp, #27]
--   81edc:	7100001f 	cmp	w0, #0x0
--   81ee0:	54000060 	b.eq	81eec <putchw+0x30>  // b.none
--   81ee4:	52800600 	mov	w0, #0x30                  	// #48
--   81ee8:	14000002 	b	81ef0 <putchw+0x34>
--   81eec:	52800400 	mov	w0, #0x20                  	// #32
--   81ef0:	3900dfe0 	strb	w0, [sp, #55]
--    char ch;
--    char* p=bf;
--   81ef4:	f9400be0 	ldr	x0, [sp, #16]
--   81ef8:	f9001fe0 	str	x0, [sp, #56]
--    while (*p++ && n > 0)
--   81efc:	14000004 	b	81f0c <putchw+0x50>
--        n--;
--   81f00:	b9401fe0 	ldr	w0, [sp, #28]
--   81f04:	51000400 	sub	w0, w0, #0x1
--   81f08:	b9001fe0 	str	w0, [sp, #28]
--    while (*p++ && n > 0)
--   81f0c:	f9401fe0 	ldr	x0, [sp, #56]
--   81f10:	91000401 	add	x1, x0, #0x1
--   81f14:	f9001fe1 	str	x1, [sp, #56]
--   81f18:	39400000 	ldrb	w0, [x0]
--   81f1c:	7100001f 	cmp	w0, #0x0
--   81f20:	54000120 	b.eq	81f44 <putchw+0x88>  // b.none
--   81f24:	b9401fe0 	ldr	w0, [sp, #28]
--   81f28:	7100001f 	cmp	w0, #0x0
--   81f2c:	54fffeac 	b.gt	81f00 <putchw+0x44>
--    while (n-- > 0)
--   81f30:	14000005 	b	81f44 <putchw+0x88>
--        putf(putp,fc);
--   81f34:	f94013e2 	ldr	x2, [sp, #32]
--   81f38:	3940dfe1 	ldrb	w1, [sp, #55]
--   81f3c:	f94017e0 	ldr	x0, [sp, #40]
--   81f40:	d63f0040 	blr	x2
--    while (n-- > 0)
--   81f44:	b9401fe0 	ldr	w0, [sp, #28]
--   81f48:	51000401 	sub	w1, w0, #0x1
--   81f4c:	b9001fe1 	str	w1, [sp, #28]
--   81f50:	7100001f 	cmp	w0, #0x0
--   81f54:	54ffff0c 	b.gt	81f34 <putchw+0x78>
--    while ((ch= *bf++))
--   81f58:	14000005 	b	81f6c <putchw+0xb0>
--        putf(putp,ch);
--   81f5c:	f94013e2 	ldr	x2, [sp, #32]
--   81f60:	3940dbe1 	ldrb	w1, [sp, #54]
--   81f64:	f94017e0 	ldr	x0, [sp, #40]
--   81f68:	d63f0040 	blr	x2
--    while ((ch= *bf++))
--   81f6c:	f9400be0 	ldr	x0, [sp, #16]
--   81f70:	91000401 	add	x1, x0, #0x1
--   81f74:	f9000be1 	str	x1, [sp, #16]
--   81f78:	39400000 	ldrb	w0, [x0]
--   81f7c:	3900dbe0 	strb	w0, [sp, #54]
--   81f80:	3940dbe0 	ldrb	w0, [sp, #54]
--   81f84:	7100001f 	cmp	w0, #0x0
--   81f88:	54fffea1 	b.ne	81f5c <putchw+0xa0>  // b.any
--    }
--   81f8c:	d503201f 	nop
--   81f90:	d503201f 	nop
--   81f94:	a8c47bfd 	ldp	x29, x30, [sp], #64
--   81f98:	d65f03c0 	ret
--
--0000000000081f9c <tfp_format>:
--
--void tfp_format(void* putp,putcf putf,char *fmt, va_list va)
--    {
--   81f9c:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
--   81fa0:	910003fd 	mov	x29, sp
--   81fa4:	f9000bf3 	str	x19, [sp, #16]
--   81fa8:	f9001fe0 	str	x0, [sp, #56]
--   81fac:	f9001be1 	str	x1, [sp, #48]
--   81fb0:	f90017e2 	str	x2, [sp, #40]
--   81fb4:	aa0303f3 	mov	x19, x3
--    char bf[12];
--
--    char ch;
--
--
--    while ((ch=*(fmt++))) {
--   81fb8:	140000ef 	b	82374 <tfp_format+0x3d8>
--        if (ch!='%')
--   81fbc:	39417fe0 	ldrb	w0, [sp, #95]
--   81fc0:	7100941f 	cmp	w0, #0x25
--   81fc4:	540000c0 	b.eq	81fdc <tfp_format+0x40>  // b.none
--            putf(putp,ch);
--   81fc8:	f9401be2 	ldr	x2, [sp, #48]
--   81fcc:	39417fe1 	ldrb	w1, [sp, #95]
--   81fd0:	f9401fe0 	ldr	x0, [sp, #56]
--   81fd4:	d63f0040 	blr	x2
--   81fd8:	140000e7 	b	82374 <tfp_format+0x3d8>
--        else {
--            char lz=0;
--   81fdc:	39017bff 	strb	wzr, [sp, #94]
--#ifdef  PRINTF_LONG_SUPPORT
--            char lng=0;
--#endif
--            int w=0;
--   81fe0:	b9004fff 	str	wzr, [sp, #76]
--            ch=*(fmt++);
--   81fe4:	f94017e0 	ldr	x0, [sp, #40]
--   81fe8:	91000401 	add	x1, x0, #0x1
--   81fec:	f90017e1 	str	x1, [sp, #40]
--   81ff0:	39400000 	ldrb	w0, [x0]
--   81ff4:	39017fe0 	strb	w0, [sp, #95]
--            if (ch=='0') {
--   81ff8:	39417fe0 	ldrb	w0, [sp, #95]
--   81ffc:	7100c01f 	cmp	w0, #0x30
--   82000:	54000101 	b.ne	82020 <tfp_format+0x84>  // b.any
--                ch=*(fmt++);
--   82004:	f94017e0 	ldr	x0, [sp, #40]
--   82008:	91000401 	add	x1, x0, #0x1
--   8200c:	f90017e1 	str	x1, [sp, #40]
--   82010:	39400000 	ldrb	w0, [x0]
--   82014:	39017fe0 	strb	w0, [sp, #95]
--                lz=1;
--   82018:	52800020 	mov	w0, #0x1                   	// #1
--   8201c:	39017be0 	strb	w0, [sp, #94]
--                }
--            if (ch>='0' && ch<='9') {
--   82020:	39417fe0 	ldrb	w0, [sp, #95]
--   82024:	7100bc1f 	cmp	w0, #0x2f
--   82028:	54000189 	b.ls	82058 <tfp_format+0xbc>  // b.plast
--   8202c:	39417fe0 	ldrb	w0, [sp, #95]
--   82030:	7100e41f 	cmp	w0, #0x39
--   82034:	54000128 	b.hi	82058 <tfp_format+0xbc>  // b.pmore
--                ch=a2i(ch,&fmt,10,&w);
--   82038:	910133e1 	add	x1, sp, #0x4c
--   8203c:	9100a3e0 	add	x0, sp, #0x28
--   82040:	aa0103e3 	mov	x3, x1
--   82044:	52800142 	mov	w2, #0xa                   	// #10
--   82048:	aa0003e1 	mov	x1, x0
--   8204c:	39417fe0 	ldrb	w0, [sp, #95]
--   82050:	97ffff70 	bl	81e10 <a2i>
--   82054:	39017fe0 	strb	w0, [sp, #95]
--            if (ch=='l') {
--                ch=*(fmt++);
--                lng=1;
--            }
--#endif
--            switch (ch) {
--   82058:	39417fe0 	ldrb	w0, [sp, #95]
--   8205c:	7101e01f 	cmp	w0, #0x78
--   82060:	54000be0 	b.eq	821dc <tfp_format+0x240>  // b.none
--   82064:	7101e01f 	cmp	w0, #0x78
--   82068:	5400184c 	b.gt	82370 <tfp_format+0x3d4>
--   8206c:	7101d41f 	cmp	w0, #0x75
--   82070:	54000300 	b.eq	820d0 <tfp_format+0x134>  // b.none
--   82074:	7101d41f 	cmp	w0, #0x75
--   82078:	540017cc 	b.gt	82370 <tfp_format+0x3d4>
--   8207c:	7101cc1f 	cmp	w0, #0x73
--   82080:	54001360 	b.eq	822ec <tfp_format+0x350>  // b.none
--   82084:	7101cc1f 	cmp	w0, #0x73
--   82088:	5400174c 	b.gt	82370 <tfp_format+0x3d4>
--   8208c:	7101901f 	cmp	w0, #0x64
--   82090:	54000660 	b.eq	8215c <tfp_format+0x1c0>  // b.none
--   82094:	7101901f 	cmp	w0, #0x64
--   82098:	540016cc 	b.gt	82370 <tfp_format+0x3d4>
--   8209c:	71018c1f 	cmp	w0, #0x63
--   820a0:	54000f00 	b.eq	82280 <tfp_format+0x2e4>  // b.none
--   820a4:	71018c1f 	cmp	w0, #0x63
--   820a8:	5400164c 	b.gt	82370 <tfp_format+0x3d4>
--   820ac:	7101601f 	cmp	w0, #0x58
--   820b0:	54000960 	b.eq	821dc <tfp_format+0x240>  // b.none
--   820b4:	7101601f 	cmp	w0, #0x58
--   820b8:	540015cc 	b.gt	82370 <tfp_format+0x3d4>
--   820bc:	7100001f 	cmp	w0, #0x0
--   820c0:	540016c0 	b.eq	82398 <tfp_format+0x3fc>  // b.none
--   820c4:	7100941f 	cmp	w0, #0x25
--   820c8:	540014c0 	b.eq	82360 <tfp_format+0x3c4>  // b.none
--                    putchw(putp,putf,w,0,va_arg(va, char*));
--                    break;
--                case '%' :
--                    putf(putp,ch);
--                default:
--                    break;
--   820cc:	140000a9 	b	82370 <tfp_format+0x3d4>
--                    ui2a(va_arg(va, unsigned int),10,0,bf);
--   820d0:	b9401a61 	ldr	w1, [x19, #24]
--   820d4:	f9400260 	ldr	x0, [x19]
--   820d8:	7100003f 	cmp	w1, #0x0
--   820dc:	540000ab 	b.lt	820f0 <tfp_format+0x154>  // b.tstop
--   820e0:	91002c01 	add	x1, x0, #0xb
--   820e4:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   820e8:	f9000261 	str	x1, [x19]
--   820ec:	1400000d 	b	82120 <tfp_format+0x184>
--   820f0:	11002022 	add	w2, w1, #0x8
--   820f4:	b9001a62 	str	w2, [x19, #24]
--   820f8:	b9401a62 	ldr	w2, [x19, #24]
--   820fc:	7100005f 	cmp	w2, #0x0
--   82100:	540000ad 	b.le	82114 <tfp_format+0x178>
--   82104:	91002c01 	add	x1, x0, #0xb
--   82108:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   8210c:	f9000261 	str	x1, [x19]
--   82110:	14000004 	b	82120 <tfp_format+0x184>
--   82114:	f9400662 	ldr	x2, [x19, #8]
--   82118:	93407c20 	sxtw	x0, w1
--   8211c:	8b000040 	add	x0, x2, x0
--   82120:	b9400000 	ldr	w0, [x0]
--   82124:	910143e1 	add	x1, sp, #0x50
--   82128:	aa0103e3 	mov	x3, x1
--   8212c:	52800002 	mov	w2, #0x0                   	// #0
--   82130:	52800141 	mov	w1, #0xa                   	// #10
--   82134:	97fffeb6 	bl	81c0c <ui2a>
--                    putchw(putp,putf,w,lz,bf);
--   82138:	b9404fe0 	ldr	w0, [sp, #76]
--   8213c:	910143e1 	add	x1, sp, #0x50
--   82140:	aa0103e4 	mov	x4, x1
--   82144:	39417be3 	ldrb	w3, [sp, #94]
--   82148:	2a0003e2 	mov	w2, w0
--   8214c:	f9401be1 	ldr	x1, [sp, #48]
--   82150:	f9401fe0 	ldr	x0, [sp, #56]
--   82154:	97ffff5a 	bl	81ebc <putchw>
--                    break;
--   82158:	14000087 	b	82374 <tfp_format+0x3d8>
--                    i2a(va_arg(va, int),bf);
--   8215c:	b9401a61 	ldr	w1, [x19, #24]
--   82160:	f9400260 	ldr	x0, [x19]
--   82164:	7100003f 	cmp	w1, #0x0
--   82168:	540000ab 	b.lt	8217c <tfp_format+0x1e0>  // b.tstop
--   8216c:	91002c01 	add	x1, x0, #0xb
--   82170:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   82174:	f9000261 	str	x1, [x19]
--   82178:	1400000d 	b	821ac <tfp_format+0x210>
--   8217c:	11002022 	add	w2, w1, #0x8
--   82180:	b9001a62 	str	w2, [x19, #24]
--   82184:	b9401a62 	ldr	w2, [x19, #24]
--   82188:	7100005f 	cmp	w2, #0x0
--   8218c:	540000ad 	b.le	821a0 <tfp_format+0x204>
--   82190:	91002c01 	add	x1, x0, #0xb
--   82194:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   82198:	f9000261 	str	x1, [x19]
--   8219c:	14000004 	b	821ac <tfp_format+0x210>
--   821a0:	f9400662 	ldr	x2, [x19, #8]
--   821a4:	93407c20 	sxtw	x0, w1
--   821a8:	8b000040 	add	x0, x2, x0
--   821ac:	b9400000 	ldr	w0, [x0]
--   821b0:	910143e1 	add	x1, sp, #0x50
--   821b4:	97fffee0 	bl	81d34 <i2a>
--                    putchw(putp,putf,w,lz,bf);
--   821b8:	b9404fe0 	ldr	w0, [sp, #76]
--   821bc:	910143e1 	add	x1, sp, #0x50
--   821c0:	aa0103e4 	mov	x4, x1
--   821c4:	39417be3 	ldrb	w3, [sp, #94]
--   821c8:	2a0003e2 	mov	w2, w0
--   821cc:	f9401be1 	ldr	x1, [sp, #48]
--   821d0:	f9401fe0 	ldr	x0, [sp, #56]
--   821d4:	97ffff3a 	bl	81ebc <putchw>
--                    break;
--   821d8:	14000067 	b	82374 <tfp_format+0x3d8>
--                    ui2a(va_arg(va, unsigned int),16,(ch=='X'),bf);
--   821dc:	b9401a61 	ldr	w1, [x19, #24]
--   821e0:	f9400260 	ldr	x0, [x19]
--   821e4:	7100003f 	cmp	w1, #0x0
--   821e8:	540000ab 	b.lt	821fc <tfp_format+0x260>  // b.tstop
--   821ec:	91002c01 	add	x1, x0, #0xb
--   821f0:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   821f4:	f9000261 	str	x1, [x19]
--   821f8:	1400000d 	b	8222c <tfp_format+0x290>
--   821fc:	11002022 	add	w2, w1, #0x8
--   82200:	b9001a62 	str	w2, [x19, #24]
--   82204:	b9401a62 	ldr	w2, [x19, #24]
--   82208:	7100005f 	cmp	w2, #0x0
--   8220c:	540000ad 	b.le	82220 <tfp_format+0x284>
--   82210:	91002c01 	add	x1, x0, #0xb
--   82214:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   82218:	f9000261 	str	x1, [x19]
--   8221c:	14000004 	b	8222c <tfp_format+0x290>
--   82220:	f9400662 	ldr	x2, [x19, #8]
--   82224:	93407c20 	sxtw	x0, w1
--   82228:	8b000040 	add	x0, x2, x0
--   8222c:	b9400004 	ldr	w4, [x0]
--   82230:	39417fe0 	ldrb	w0, [sp, #95]
--   82234:	7101601f 	cmp	w0, #0x58
--   82238:	1a9f17e0 	cset	w0, eq  // eq = none
--   8223c:	12001c00 	and	w0, w0, #0xff
--   82240:	2a0003e1 	mov	w1, w0
--   82244:	910143e0 	add	x0, sp, #0x50
--   82248:	aa0003e3 	mov	x3, x0
--   8224c:	2a0103e2 	mov	w2, w1
--   82250:	52800201 	mov	w1, #0x10                  	// #16
--   82254:	2a0403e0 	mov	w0, w4
--   82258:	97fffe6d 	bl	81c0c <ui2a>
--                    putchw(putp,putf,w,lz,bf);
--   8225c:	b9404fe0 	ldr	w0, [sp, #76]
--   82260:	910143e1 	add	x1, sp, #0x50
--   82264:	aa0103e4 	mov	x4, x1
--   82268:	39417be3 	ldrb	w3, [sp, #94]
--   8226c:	2a0003e2 	mov	w2, w0
--   82270:	f9401be1 	ldr	x1, [sp, #48]
--   82274:	f9401fe0 	ldr	x0, [sp, #56]
--   82278:	97ffff11 	bl	81ebc <putchw>
--                    break;
--   8227c:	1400003e 	b	82374 <tfp_format+0x3d8>
--                    putf(putp,(char)(va_arg(va, int)));
--   82280:	b9401a61 	ldr	w1, [x19, #24]
--   82284:	f9400260 	ldr	x0, [x19]
--   82288:	7100003f 	cmp	w1, #0x0
--   8228c:	540000ab 	b.lt	822a0 <tfp_format+0x304>  // b.tstop
--   82290:	91002c01 	add	x1, x0, #0xb
--   82294:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   82298:	f9000261 	str	x1, [x19]
--   8229c:	1400000d 	b	822d0 <tfp_format+0x334>
--   822a0:	11002022 	add	w2, w1, #0x8
--   822a4:	b9001a62 	str	w2, [x19, #24]
--   822a8:	b9401a62 	ldr	w2, [x19, #24]
--   822ac:	7100005f 	cmp	w2, #0x0
--   822b0:	540000ad 	b.le	822c4 <tfp_format+0x328>
--   822b4:	91002c01 	add	x1, x0, #0xb
--   822b8:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   822bc:	f9000261 	str	x1, [x19]
--   822c0:	14000004 	b	822d0 <tfp_format+0x334>
--   822c4:	f9400662 	ldr	x2, [x19, #8]
--   822c8:	93407c20 	sxtw	x0, w1
--   822cc:	8b000040 	add	x0, x2, x0
--   822d0:	b9400000 	ldr	w0, [x0]
--   822d4:	12001c00 	and	w0, w0, #0xff
--   822d8:	f9401be2 	ldr	x2, [sp, #48]
--   822dc:	2a0003e1 	mov	w1, w0
--   822e0:	f9401fe0 	ldr	x0, [sp, #56]
--   822e4:	d63f0040 	blr	x2
--                    break;
--   822e8:	14000023 	b	82374 <tfp_format+0x3d8>
--                    putchw(putp,putf,w,0,va_arg(va, char*));
--   822ec:	b9404fe5 	ldr	w5, [sp, #76]
--   822f0:	b9401a61 	ldr	w1, [x19, #24]
--   822f4:	f9400260 	ldr	x0, [x19]
--   822f8:	7100003f 	cmp	w1, #0x0
--   822fc:	540000ab 	b.lt	82310 <tfp_format+0x374>  // b.tstop
--   82300:	91003c01 	add	x1, x0, #0xf
--   82304:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   82308:	f9000261 	str	x1, [x19]
--   8230c:	1400000d 	b	82340 <tfp_format+0x3a4>
--   82310:	11002022 	add	w2, w1, #0x8
--   82314:	b9001a62 	str	w2, [x19, #24]
--   82318:	b9401a62 	ldr	w2, [x19, #24]
--   8231c:	7100005f 	cmp	w2, #0x0
--   82320:	540000ad 	b.le	82334 <tfp_format+0x398>
--   82324:	91003c01 	add	x1, x0, #0xf
--   82328:	927df021 	and	x1, x1, #0xfffffffffffffff8
--   8232c:	f9000261 	str	x1, [x19]
--   82330:	14000004 	b	82340 <tfp_format+0x3a4>
--   82334:	f9400662 	ldr	x2, [x19, #8]
--   82338:	93407c20 	sxtw	x0, w1
--   8233c:	8b000040 	add	x0, x2, x0
--   82340:	f9400000 	ldr	x0, [x0]
--   82344:	aa0003e4 	mov	x4, x0
--   82348:	52800003 	mov	w3, #0x0                   	// #0
--   8234c:	2a0503e2 	mov	w2, w5
--   82350:	f9401be1 	ldr	x1, [sp, #48]
--   82354:	f9401fe0 	ldr	x0, [sp, #56]
--   82358:	97fffed9 	bl	81ebc <putchw>
--                    break;
--   8235c:	14000006 	b	82374 <tfp_format+0x3d8>
--                    putf(putp,ch);
--   82360:	f9401be2 	ldr	x2, [sp, #48]
--   82364:	39417fe1 	ldrb	w1, [sp, #95]
--   82368:	f9401fe0 	ldr	x0, [sp, #56]
--   8236c:	d63f0040 	blr	x2
--                    break;
--   82370:	d503201f 	nop
--    while ((ch=*(fmt++))) {
--   82374:	f94017e0 	ldr	x0, [sp, #40]
--   82378:	91000401 	add	x1, x0, #0x1
--   8237c:	f90017e1 	str	x1, [sp, #40]
--   82380:	39400000 	ldrb	w0, [x0]
--   82384:	39017fe0 	strb	w0, [sp, #95]
--   82388:	39417fe0 	ldrb	w0, [sp, #95]
--   8238c:	7100001f 	cmp	w0, #0x0
--   82390:	54ffe161 	b.ne	81fbc <tfp_format+0x20>  // b.any
--                }
--            }
--        }
--    abort:;
--   82394:	14000002 	b	8239c <tfp_format+0x400>
--                    goto abort;
--   82398:	d503201f 	nop
--    }
--   8239c:	d503201f 	nop
--   823a0:	f9400bf3 	ldr	x19, [sp, #16]
--   823a4:	a8c67bfd 	ldp	x29, x30, [sp], #96
--   823a8:	d65f03c0 	ret
--
--00000000000823ac <init_printf>:
--
--
--void init_printf(void* putp,void (*putf) (void*,char))
--    {
--   823ac:	d10043ff 	sub	sp, sp, #0x10
--   823b0:	f90007e0 	str	x0, [sp, #8]
--   823b4:	f90003e1 	str	x1, [sp]
--    stdout_putf=putf;
--   823b8:	d00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   823bc:	91384000 	add	x0, x0, #0xe10
--   823c0:	f94003e1 	ldr	x1, [sp]
--   823c4:	f9000001 	str	x1, [x0]
--    stdout_putp=putp;
--   823c8:	d00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   823cc:	91386000 	add	x0, x0, #0xe18
--   823d0:	f94007e1 	ldr	x1, [sp, #8]
--   823d4:	f9000001 	str	x1, [x0]
--    }
--   823d8:	d503201f 	nop
--   823dc:	910043ff 	add	sp, sp, #0x10
--   823e0:	d65f03c0 	ret
--
--00000000000823e4 <tfp_printf>:
--
--void tfp_printf(char *fmt, ...)
--    {
--   823e4:	a9b67bfd 	stp	x29, x30, [sp, #-160]!
--   823e8:	910003fd 	mov	x29, sp
--   823ec:	f9001fe0 	str	x0, [sp, #56]
--   823f0:	f90037e1 	str	x1, [sp, #104]
--   823f4:	f9003be2 	str	x2, [sp, #112]
--   823f8:	f9003fe3 	str	x3, [sp, #120]
--   823fc:	f90043e4 	str	x4, [sp, #128]
--   82400:	f90047e5 	str	x5, [sp, #136]
--   82404:	f9004be6 	str	x6, [sp, #144]
--   82408:	f9004fe7 	str	x7, [sp, #152]
--    va_list va;
--    va_start(va,fmt);
--   8240c:	910283e0 	add	x0, sp, #0xa0
--   82410:	f90023e0 	str	x0, [sp, #64]
--   82414:	910283e0 	add	x0, sp, #0xa0
--   82418:	f90027e0 	str	x0, [sp, #72]
--   8241c:	910183e0 	add	x0, sp, #0x60
--   82420:	f9002be0 	str	x0, [sp, #80]
--   82424:	128006e0 	mov	w0, #0xffffffc8            	// #-56
--   82428:	b9005be0 	str	w0, [sp, #88]
--   8242c:	b9005fff 	str	wzr, [sp, #92]
--    tfp_format(stdout_putp,stdout_putf,fmt,va);
--   82430:	d00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   82434:	91386000 	add	x0, x0, #0xe18
--   82438:	f9400004 	ldr	x4, [x0]
--   8243c:	d00003e0 	adrp	x0, 100000 <mem_map+0x7c9f8>
--   82440:	91384000 	add	x0, x0, #0xe10
--   82444:	f9400005 	ldr	x5, [x0]
--   82448:	910043e2 	add	x2, sp, #0x10
--   8244c:	910103e3 	add	x3, sp, #0x40
--   82450:	a9400460 	ldp	x0, x1, [x3]
--   82454:	a9000440 	stp	x0, x1, [x2]
--   82458:	a9410460 	ldp	x0, x1, [x3, #16]
--   8245c:	a9010440 	stp	x0, x1, [x2, #16]
--   82460:	910043e0 	add	x0, sp, #0x10
--   82464:	aa0003e3 	mov	x3, x0
--   82468:	f9401fe2 	ldr	x2, [sp, #56]
--   8246c:	aa0503e1 	mov	x1, x5
--   82470:	aa0403e0 	mov	x0, x4
--   82474:	97fffeca 	bl	81f9c <tfp_format>
--    va_end(va);
--    }
--   82478:	d503201f 	nop
--   8247c:	a8ca7bfd 	ldp	x29, x30, [sp], #160
--   82480:	d65f03c0 	ret
--
--0000000000082484 <putcp>:
--
--static void putcp(void* p,char c)
--    {
--   82484:	d10043ff 	sub	sp, sp, #0x10
--   82488:	f90007e0 	str	x0, [sp, #8]
--   8248c:	39001fe1 	strb	w1, [sp, #7]
--    *(*((char**)p))++ = c;
--   82490:	f94007e0 	ldr	x0, [sp, #8]
--   82494:	f9400000 	ldr	x0, [x0]
--   82498:	91000402 	add	x2, x0, #0x1
--   8249c:	f94007e1 	ldr	x1, [sp, #8]
--   824a0:	f9000022 	str	x2, [x1]
--   824a4:	39401fe1 	ldrb	w1, [sp, #7]
--   824a8:	39000001 	strb	w1, [x0]
--    }
--   824ac:	d503201f 	nop
--   824b0:	910043ff 	add	sp, sp, #0x10
--   824b4:	d65f03c0 	ret
--
--00000000000824b8 <tfp_sprintf>:
--
--
--
--void tfp_sprintf(char* s,char *fmt, ...)
--    {
--   824b8:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
--   824bc:	910003fd 	mov	x29, sp
--   824c0:	f9001fe0 	str	x0, [sp, #56]
--   824c4:	f9001be1 	str	x1, [sp, #48]
--   824c8:	f90033e2 	str	x2, [sp, #96]
--   824cc:	f90037e3 	str	x3, [sp, #104]
--   824d0:	f9003be4 	str	x4, [sp, #112]
--   824d4:	f9003fe5 	str	x5, [sp, #120]
--   824d8:	f90043e6 	str	x6, [sp, #128]
--   824dc:	f90047e7 	str	x7, [sp, #136]
--    va_list va;
--    va_start(va,fmt);
--   824e0:	910243e0 	add	x0, sp, #0x90
--   824e4:	f90023e0 	str	x0, [sp, #64]
--   824e8:	910243e0 	add	x0, sp, #0x90
--   824ec:	f90027e0 	str	x0, [sp, #72]
--   824f0:	910183e0 	add	x0, sp, #0x60
--   824f4:	f9002be0 	str	x0, [sp, #80]
--   824f8:	128005e0 	mov	w0, #0xffffffd0            	// #-48
--   824fc:	b9005be0 	str	w0, [sp, #88]
--   82500:	b9005fff 	str	wzr, [sp, #92]
--    tfp_format(&s,putcp,fmt,va);
--   82504:	910043e2 	add	x2, sp, #0x10
--   82508:	910103e3 	add	x3, sp, #0x40
--   8250c:	a9400460 	ldp	x0, x1, [x3]
--   82510:	a9000440 	stp	x0, x1, [x2]
--   82514:	a9410460 	ldp	x0, x1, [x3, #16]
--   82518:	a9010440 	stp	x0, x1, [x2, #16]
--   8251c:	910043e0 	add	x0, sp, #0x10
--   82520:	9100e3e4 	add	x4, sp, #0x38
--   82524:	aa0003e3 	mov	x3, x0
--   82528:	f9401be2 	ldr	x2, [sp, #48]
--   8252c:	90000000 	adrp	x0, 82000 <tfp_format+0x64>
--   82530:	91121001 	add	x1, x0, #0x484
--   82534:	aa0403e0 	mov	x0, x4
--   82538:	97fffe99 	bl	81f9c <tfp_format>
--    putcp(&s,0);
--   8253c:	9100e3e0 	add	x0, sp, #0x38
--   82540:	52800001 	mov	w1, #0x0                   	// #0
--   82544:	97ffffd0 	bl	82484 <putcp>
--    va_end(va);
--    }
--   82548:	d503201f 	nop
--   8254c:	a8c97bfd 	ldp	x29, x30, [sp], #144
--   82550:	d65f03c0 	ret
--
--0000000000082554 <mbox_call>:
--
--/**
-- * Make a mailbox call. Returns 0 on failure, non-zero on success
-- */
--int mbox_call(unsigned char ch)
--{
--   82554:	d10083ff 	sub	sp, sp, #0x20
--   82558:	39003fe0 	strb	w0, [sp, #15]
--    unsigned int r = (((unsigned int)((unsigned long)&mbox)&~0xF) | (ch&0xF));
--   8255c:	39403fe0 	ldrb	w0, [sp, #15]
--   82560:	12000c01 	and	w1, w0, #0xf
--   82564:	d0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   82568:	f940bc00 	ldr	x0, [x0, #376]
--   8256c:	121c6c00 	and	w0, w0, #0xfffffff0
--   82570:	2a000020 	orr	w0, w1, w0
--   82574:	b9001fe0 	str	w0, [sp, #28]
--    /* wait until we can write to the mailbox */
--    do{asm volatile("nop");}while(*MBOX_STATUS & MBOX_FULL);
--   82578:	d503201f 	nop
--   8257c:	d2971300 	mov	x0, #0xb898                	// #47256
--   82580:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   82584:	b9400000 	ldr	w0, [x0]
--   82588:	7100001f 	cmp	w0, #0x0
--   8258c:	54ffff6b 	b.lt	82578 <mbox_call+0x24>  // b.tstop
--    /* write the address of our message to the mailbox with channel identifier */
--    *MBOX_WRITE = r;
--   82590:	d2971400 	mov	x0, #0xb8a0                	// #47264
--   82594:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   82598:	b9401fe1 	ldr	w1, [sp, #28]
--   8259c:	b9000001 	str	w1, [x0]
--    /* now wait for the response */
--    while(1) {
--        /* is there a response? */
--        do{asm volatile("nop");}while(*MBOX_STATUS & MBOX_EMPTY);
--   825a0:	d503201f 	nop
--   825a4:	d2971300 	mov	x0, #0xb898                	// #47256
--   825a8:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   825ac:	b9400000 	ldr	w0, [x0]
--   825b0:	12020000 	and	w0, w0, #0x40000000
--   825b4:	7100001f 	cmp	w0, #0x0
--   825b8:	54ffff41 	b.ne	825a0 <mbox_call+0x4c>  // b.any
--        /* is it a response to our message? */
--        if(r == *MBOX_READ)
--   825bc:	d2971000 	mov	x0, #0xb880                	// #47232
--   825c0:	f2a7e000 	movk	x0, #0x3f00, lsl #16
--   825c4:	b9400000 	ldr	w0, [x0]
--   825c8:	b9401fe1 	ldr	w1, [sp, #28]
--   825cc:	6b00003f 	cmp	w1, w0
--   825d0:	54fffe81 	b.ne	825a0 <mbox_call+0x4c>  // b.any
--            /* is it a valid successful response? */
--            return mbox[1]==MBOX_RESPONSE;
--   825d4:	d0000bc0 	adrp	x0, 1fc000 <task+0x90>
--   825d8:	f940bc00 	ldr	x0, [x0, #376]
--   825dc:	b9400401 	ldr	w1, [x0, #4]
--   825e0:	52b00000 	mov	w0, #0x80000000            	// #-2147483648
--   825e4:	6b00003f 	cmp	w1, w0
--   825e8:	1a9f17e0 	cset	w0, eq  // eq = none
--   825ec:	12001c00 	and	w0, w0, #0xff
--    }
--    return 0;
--}
--   825f0:	910083ff 	add	sp, sp, #0x20
--   825f4:	d65f03c0 	ret
--
--00000000000825f8 <gen_timer_init>:
-- *  https://developer.arm.com/docs/ddi0487/ca/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
-- */
--
--.globl gen_timer_init
--gen_timer_init:
--	mov x0, #1
--   825f8:	d2800020 	mov	x0, #0x1                   	// #1
--	msr CNTP_CTL_EL0, x0
--   825fc:	d51be220 	msr	cntp_ctl_el0, x0
--	ret
--   82600:	d65f03c0 	ret
--
--0000000000082604 <gen_timer_reset>:
--
--.globl gen_timer_reset
--gen_timer_reset:
--#    mov x0, #1
--#	lsl x0, x0, #24
--	msr CNTP_TVAL_EL0, x0
--   82604:	d51be200 	msr	cntp_tval_el0, x0
--    ret
--   82608:	d65f03c0 	ret
--	...
--
--0000000000082800 <vectors>:
-- * Exception vectors.
-- */
--.align	11
--.globl vectors 
--vectors:
--	ventry	sync_invalid_el1t			// Synchronous EL1t
--   82800:	140001e1 	b	82f84 <sync_invalid_el1t>
--   82804:	d503201f 	nop
--   82808:	d503201f 	nop
--   8280c:	d503201f 	nop
--   82810:	d503201f 	nop
--   82814:	d503201f 	nop
--   82818:	d503201f 	nop
--   8281c:	d503201f 	nop
--   82820:	d503201f 	nop
--   82824:	d503201f 	nop
--   82828:	d503201f 	nop
--   8282c:	d503201f 	nop
--   82830:	d503201f 	nop
--   82834:	d503201f 	nop
--   82838:	d503201f 	nop
--   8283c:	d503201f 	nop
--   82840:	d503201f 	nop
--   82844:	d503201f 	nop
--   82848:	d503201f 	nop
--   8284c:	d503201f 	nop
--   82850:	d503201f 	nop
--   82854:	d503201f 	nop
--   82858:	d503201f 	nop
--   8285c:	d503201f 	nop
--   82860:	d503201f 	nop
--   82864:	d503201f 	nop
--   82868:	d503201f 	nop
--   8286c:	d503201f 	nop
--   82870:	d503201f 	nop
--   82874:	d503201f 	nop
--   82878:	d503201f 	nop
--   8287c:	d503201f 	nop
--	ventry	irq_invalid_el1t			// IRQ EL1t
--   82880:	140001d7 	b	82fdc <irq_invalid_el1t>
--   82884:	d503201f 	nop
--   82888:	d503201f 	nop
--   8288c:	d503201f 	nop
--   82890:	d503201f 	nop
--   82894:	d503201f 	nop
--   82898:	d503201f 	nop
--   8289c:	d503201f 	nop
--   828a0:	d503201f 	nop
--   828a4:	d503201f 	nop
--   828a8:	d503201f 	nop
--   828ac:	d503201f 	nop
--   828b0:	d503201f 	nop
--   828b4:	d503201f 	nop
--   828b8:	d503201f 	nop
--   828bc:	d503201f 	nop
--   828c0:	d503201f 	nop
--   828c4:	d503201f 	nop
--   828c8:	d503201f 	nop
--   828cc:	d503201f 	nop
--   828d0:	d503201f 	nop
--   828d4:	d503201f 	nop
--   828d8:	d503201f 	nop
--   828dc:	d503201f 	nop
--   828e0:	d503201f 	nop
--   828e4:	d503201f 	nop
--   828e8:	d503201f 	nop
--   828ec:	d503201f 	nop
--   828f0:	d503201f 	nop
--   828f4:	d503201f 	nop
--   828f8:	d503201f 	nop
--   828fc:	d503201f 	nop
--	ventry	fiq_invalid_el1t			// FIQ EL1t
--   82900:	140001cd 	b	83034 <fiq_invalid_el1t>
--   82904:	d503201f 	nop
--   82908:	d503201f 	nop
--   8290c:	d503201f 	nop
--   82910:	d503201f 	nop
--   82914:	d503201f 	nop
--   82918:	d503201f 	nop
--   8291c:	d503201f 	nop
--   82920:	d503201f 	nop
--   82924:	d503201f 	nop
--   82928:	d503201f 	nop
--   8292c:	d503201f 	nop
--   82930:	d503201f 	nop
--   82934:	d503201f 	nop
--   82938:	d503201f 	nop
--   8293c:	d503201f 	nop
--   82940:	d503201f 	nop
--   82944:	d503201f 	nop
--   82948:	d503201f 	nop
--   8294c:	d503201f 	nop
--   82950:	d503201f 	nop
--   82954:	d503201f 	nop
--   82958:	d503201f 	nop
--   8295c:	d503201f 	nop
--   82960:	d503201f 	nop
--   82964:	d503201f 	nop
--   82968:	d503201f 	nop
--   8296c:	d503201f 	nop
--   82970:	d503201f 	nop
--   82974:	d503201f 	nop
--   82978:	d503201f 	nop
--   8297c:	d503201f 	nop
--	ventry	error_invalid_el1t			// Error EL1t
--   82980:	140001c3 	b	8308c <error_invalid_el1t>
--   82984:	d503201f 	nop
--   82988:	d503201f 	nop
--   8298c:	d503201f 	nop
--   82990:	d503201f 	nop
--   82994:	d503201f 	nop
--   82998:	d503201f 	nop
--   8299c:	d503201f 	nop
--   829a0:	d503201f 	nop
--   829a4:	d503201f 	nop
--   829a8:	d503201f 	nop
--   829ac:	d503201f 	nop
--   829b0:	d503201f 	nop
--   829b4:	d503201f 	nop
--   829b8:	d503201f 	nop
--   829bc:	d503201f 	nop
--   829c0:	d503201f 	nop
--   829c4:	d503201f 	nop
--   829c8:	d503201f 	nop
--   829cc:	d503201f 	nop
--   829d0:	d503201f 	nop
--   829d4:	d503201f 	nop
--   829d8:	d503201f 	nop
--   829dc:	d503201f 	nop
--   829e0:	d503201f 	nop
--   829e4:	d503201f 	nop
--   829e8:	d503201f 	nop
--   829ec:	d503201f 	nop
--   829f0:	d503201f 	nop
--   829f4:	d503201f 	nop
--   829f8:	d503201f 	nop
--   829fc:	d503201f 	nop
--
--	ventry	sync_invalid_el1h			// Synchronous EL1h
--   82a00:	140001b9 	b	830e4 <sync_invalid_el1h>
--   82a04:	d503201f 	nop
--   82a08:	d503201f 	nop
--   82a0c:	d503201f 	nop
--   82a10:	d503201f 	nop
--   82a14:	d503201f 	nop
--   82a18:	d503201f 	nop
--   82a1c:	d503201f 	nop
--   82a20:	d503201f 	nop
--   82a24:	d503201f 	nop
--   82a28:	d503201f 	nop
--   82a2c:	d503201f 	nop
--   82a30:	d503201f 	nop
--   82a34:	d503201f 	nop
--   82a38:	d503201f 	nop
--   82a3c:	d503201f 	nop
--   82a40:	d503201f 	nop
--   82a44:	d503201f 	nop
--   82a48:	d503201f 	nop
--   82a4c:	d503201f 	nop
--   82a50:	d503201f 	nop
--   82a54:	d503201f 	nop
--   82a58:	d503201f 	nop
--   82a5c:	d503201f 	nop
--   82a60:	d503201f 	nop
--   82a64:	d503201f 	nop
--   82a68:	d503201f 	nop
--   82a6c:	d503201f 	nop
--   82a70:	d503201f 	nop
--   82a74:	d503201f 	nop
--   82a78:	d503201f 	nop
--   82a7c:	d503201f 	nop
--	ventry	el1_irq					// IRQ EL1h
--   82a80:	1400028b 	b	834ac <el1_irq>
--   82a84:	d503201f 	nop
--   82a88:	d503201f 	nop
--   82a8c:	d503201f 	nop
--   82a90:	d503201f 	nop
--   82a94:	d503201f 	nop
--   82a98:	d503201f 	nop
--   82a9c:	d503201f 	nop
--   82aa0:	d503201f 	nop
--   82aa4:	d503201f 	nop
--   82aa8:	d503201f 	nop
--   82aac:	d503201f 	nop
--   82ab0:	d503201f 	nop
--   82ab4:	d503201f 	nop
--   82ab8:	d503201f 	nop
--   82abc:	d503201f 	nop
--   82ac0:	d503201f 	nop
--   82ac4:	d503201f 	nop
--   82ac8:	d503201f 	nop
--   82acc:	d503201f 	nop
--   82ad0:	d503201f 	nop
--   82ad4:	d503201f 	nop
--   82ad8:	d503201f 	nop
--   82adc:	d503201f 	nop
--   82ae0:	d503201f 	nop
--   82ae4:	d503201f 	nop
--   82ae8:	d503201f 	nop
--   82aec:	d503201f 	nop
--   82af0:	d503201f 	nop
--   82af4:	d503201f 	nop
--   82af8:	d503201f 	nop
--   82afc:	d503201f 	nop
--	ventry	fiq_invalid_el1h			// FIQ EL1h
--   82b00:	1400018f 	b	8313c <fiq_invalid_el1h>
--   82b04:	d503201f 	nop
--   82b08:	d503201f 	nop
--   82b0c:	d503201f 	nop
--   82b10:	d503201f 	nop
--   82b14:	d503201f 	nop
--   82b18:	d503201f 	nop
--   82b1c:	d503201f 	nop
--   82b20:	d503201f 	nop
--   82b24:	d503201f 	nop
--   82b28:	d503201f 	nop
--   82b2c:	d503201f 	nop
--   82b30:	d503201f 	nop
--   82b34:	d503201f 	nop
--   82b38:	d503201f 	nop
--   82b3c:	d503201f 	nop
--   82b40:	d503201f 	nop
--   82b44:	d503201f 	nop
--   82b48:	d503201f 	nop
--   82b4c:	d503201f 	nop
--   82b50:	d503201f 	nop
--   82b54:	d503201f 	nop
--   82b58:	d503201f 	nop
--   82b5c:	d503201f 	nop
--   82b60:	d503201f 	nop
--   82b64:	d503201f 	nop
--   82b68:	d503201f 	nop
--   82b6c:	d503201f 	nop
--   82b70:	d503201f 	nop
--   82b74:	d503201f 	nop
--   82b78:	d503201f 	nop
--   82b7c:	d503201f 	nop
--	ventry	error_invalid_el1h			// Error EL1h
--   82b80:	14000185 	b	83194 <error_invalid_el1h>
--   82b84:	d503201f 	nop
--   82b88:	d503201f 	nop
--   82b8c:	d503201f 	nop
--   82b90:	d503201f 	nop
--   82b94:	d503201f 	nop
--   82b98:	d503201f 	nop
--   82b9c:	d503201f 	nop
--   82ba0:	d503201f 	nop
--   82ba4:	d503201f 	nop
--   82ba8:	d503201f 	nop
--   82bac:	d503201f 	nop
--   82bb0:	d503201f 	nop
--   82bb4:	d503201f 	nop
--   82bb8:	d503201f 	nop
--   82bbc:	d503201f 	nop
--   82bc0:	d503201f 	nop
--   82bc4:	d503201f 	nop
--   82bc8:	d503201f 	nop
--   82bcc:	d503201f 	nop
--   82bd0:	d503201f 	nop
--   82bd4:	d503201f 	nop
--   82bd8:	d503201f 	nop
--   82bdc:	d503201f 	nop
--   82be0:	d503201f 	nop
--   82be4:	d503201f 	nop
--   82be8:	d503201f 	nop
--   82bec:	d503201f 	nop
--   82bf0:	d503201f 	nop
--   82bf4:	d503201f 	nop
--   82bf8:	d503201f 	nop
--   82bfc:	d503201f 	nop
--
--	ventry	sync_invalid_el0_64			// Synchronous 64-bit EL0
--   82c00:	1400017b 	b	831ec <sync_invalid_el0_64>
--   82c04:	d503201f 	nop
--   82c08:	d503201f 	nop
--   82c0c:	d503201f 	nop
--   82c10:	d503201f 	nop
--   82c14:	d503201f 	nop
--   82c18:	d503201f 	nop
--   82c1c:	d503201f 	nop
--   82c20:	d503201f 	nop
--   82c24:	d503201f 	nop
--   82c28:	d503201f 	nop
--   82c2c:	d503201f 	nop
--   82c30:	d503201f 	nop
--   82c34:	d503201f 	nop
--   82c38:	d503201f 	nop
--   82c3c:	d503201f 	nop
--   82c40:	d503201f 	nop
--   82c44:	d503201f 	nop
--   82c48:	d503201f 	nop
--   82c4c:	d503201f 	nop
--   82c50:	d503201f 	nop
--   82c54:	d503201f 	nop
--   82c58:	d503201f 	nop
--   82c5c:	d503201f 	nop
--   82c60:	d503201f 	nop
--   82c64:	d503201f 	nop
--   82c68:	d503201f 	nop
--   82c6c:	d503201f 	nop
--   82c70:	d503201f 	nop
--   82c74:	d503201f 	nop
--   82c78:	d503201f 	nop
--   82c7c:	d503201f 	nop
--	ventry	irq_invalid_el0_64			// IRQ 64-bit EL0
--   82c80:	14000171 	b	83244 <irq_invalid_el0_64>
--   82c84:	d503201f 	nop
--   82c88:	d503201f 	nop
--   82c8c:	d503201f 	nop
--   82c90:	d503201f 	nop
--   82c94:	d503201f 	nop
--   82c98:	d503201f 	nop
--   82c9c:	d503201f 	nop
--   82ca0:	d503201f 	nop
--   82ca4:	d503201f 	nop
--   82ca8:	d503201f 	nop
--   82cac:	d503201f 	nop
--   82cb0:	d503201f 	nop
--   82cb4:	d503201f 	nop
--   82cb8:	d503201f 	nop
--   82cbc:	d503201f 	nop
--   82cc0:	d503201f 	nop
--   82cc4:	d503201f 	nop
--   82cc8:	d503201f 	nop
--   82ccc:	d503201f 	nop
--   82cd0:	d503201f 	nop
--   82cd4:	d503201f 	nop
--   82cd8:	d503201f 	nop
--   82cdc:	d503201f 	nop
--   82ce0:	d503201f 	nop
--   82ce4:	d503201f 	nop
--   82ce8:	d503201f 	nop
--   82cec:	d503201f 	nop
--   82cf0:	d503201f 	nop
--   82cf4:	d503201f 	nop
--   82cf8:	d503201f 	nop
--   82cfc:	d503201f 	nop
--	ventry	fiq_invalid_el0_64			// FIQ 64-bit EL0
--   82d00:	14000167 	b	8329c <fiq_invalid_el0_64>
--   82d04:	d503201f 	nop
--   82d08:	d503201f 	nop
--   82d0c:	d503201f 	nop
--   82d10:	d503201f 	nop
--   82d14:	d503201f 	nop
--   82d18:	d503201f 	nop
--   82d1c:	d503201f 	nop
--   82d20:	d503201f 	nop
--   82d24:	d503201f 	nop
--   82d28:	d503201f 	nop
--   82d2c:	d503201f 	nop
--   82d30:	d503201f 	nop
--   82d34:	d503201f 	nop
--   82d38:	d503201f 	nop
--   82d3c:	d503201f 	nop
--   82d40:	d503201f 	nop
--   82d44:	d503201f 	nop
--   82d48:	d503201f 	nop
--   82d4c:	d503201f 	nop
--   82d50:	d503201f 	nop
--   82d54:	d503201f 	nop
--   82d58:	d503201f 	nop
--   82d5c:	d503201f 	nop
--   82d60:	d503201f 	nop
--   82d64:	d503201f 	nop
--   82d68:	d503201f 	nop
--   82d6c:	d503201f 	nop
--   82d70:	d503201f 	nop
--   82d74:	d503201f 	nop
--   82d78:	d503201f 	nop
--   82d7c:	d503201f 	nop
--	ventry	error_invalid_el0_64			// Error 64-bit EL0
--   82d80:	1400015d 	b	832f4 <error_invalid_el0_64>
--   82d84:	d503201f 	nop
--   82d88:	d503201f 	nop
--   82d8c:	d503201f 	nop
--   82d90:	d503201f 	nop
--   82d94:	d503201f 	nop
--   82d98:	d503201f 	nop
--   82d9c:	d503201f 	nop
--   82da0:	d503201f 	nop
--   82da4:	d503201f 	nop
--   82da8:	d503201f 	nop
--   82dac:	d503201f 	nop
--   82db0:	d503201f 	nop
--   82db4:	d503201f 	nop
--   82db8:	d503201f 	nop
--   82dbc:	d503201f 	nop
--   82dc0:	d503201f 	nop
--   82dc4:	d503201f 	nop
--   82dc8:	d503201f 	nop
--   82dcc:	d503201f 	nop
--   82dd0:	d503201f 	nop
--   82dd4:	d503201f 	nop
--   82dd8:	d503201f 	nop
--   82ddc:	d503201f 	nop
--   82de0:	d503201f 	nop
--   82de4:	d503201f 	nop
--   82de8:	d503201f 	nop
--   82dec:	d503201f 	nop
--   82df0:	d503201f 	nop
--   82df4:	d503201f 	nop
--   82df8:	d503201f 	nop
--   82dfc:	d503201f 	nop
--
--	ventry	sync_invalid_el0_32			// Synchronous 32-bit EL0
--   82e00:	14000153 	b	8334c <sync_invalid_el0_32>
--   82e04:	d503201f 	nop
--   82e08:	d503201f 	nop
--   82e0c:	d503201f 	nop
--   82e10:	d503201f 	nop
--   82e14:	d503201f 	nop
--   82e18:	d503201f 	nop
--   82e1c:	d503201f 	nop
--   82e20:	d503201f 	nop
--   82e24:	d503201f 	nop
--   82e28:	d503201f 	nop
--   82e2c:	d503201f 	nop
--   82e30:	d503201f 	nop
--   82e34:	d503201f 	nop
--   82e38:	d503201f 	nop
--   82e3c:	d503201f 	nop
--   82e40:	d503201f 	nop
--   82e44:	d503201f 	nop
--   82e48:	d503201f 	nop
--   82e4c:	d503201f 	nop
--   82e50:	d503201f 	nop
--   82e54:	d503201f 	nop
--   82e58:	d503201f 	nop
--   82e5c:	d503201f 	nop
--   82e60:	d503201f 	nop
--   82e64:	d503201f 	nop
--   82e68:	d503201f 	nop
--   82e6c:	d503201f 	nop
--   82e70:	d503201f 	nop
--   82e74:	d503201f 	nop
--   82e78:	d503201f 	nop
--   82e7c:	d503201f 	nop
--	ventry	irq_invalid_el0_32			// IRQ 32-bit EL0
--   82e80:	14000149 	b	833a4 <irq_invalid_el0_32>
--   82e84:	d503201f 	nop
--   82e88:	d503201f 	nop
--   82e8c:	d503201f 	nop
--   82e90:	d503201f 	nop
--   82e94:	d503201f 	nop
--   82e98:	d503201f 	nop
--   82e9c:	d503201f 	nop
--   82ea0:	d503201f 	nop
--   82ea4:	d503201f 	nop
--   82ea8:	d503201f 	nop
--   82eac:	d503201f 	nop
--   82eb0:	d503201f 	nop
--   82eb4:	d503201f 	nop
--   82eb8:	d503201f 	nop
--   82ebc:	d503201f 	nop
--   82ec0:	d503201f 	nop
--   82ec4:	d503201f 	nop
--   82ec8:	d503201f 	nop
--   82ecc:	d503201f 	nop
--   82ed0:	d503201f 	nop
--   82ed4:	d503201f 	nop
--   82ed8:	d503201f 	nop
--   82edc:	d503201f 	nop
--   82ee0:	d503201f 	nop
--   82ee4:	d503201f 	nop
--   82ee8:	d503201f 	nop
--   82eec:	d503201f 	nop
--   82ef0:	d503201f 	nop
--   82ef4:	d503201f 	nop
--   82ef8:	d503201f 	nop
--   82efc:	d503201f 	nop
--	ventry	fiq_invalid_el0_32			// FIQ 32-bit EL0
--   82f00:	1400013f 	b	833fc <fiq_invalid_el0_32>
--   82f04:	d503201f 	nop
--   82f08:	d503201f 	nop
--   82f0c:	d503201f 	nop
--   82f10:	d503201f 	nop
--   82f14:	d503201f 	nop
--   82f18:	d503201f 	nop
--   82f1c:	d503201f 	nop
--   82f20:	d503201f 	nop
--   82f24:	d503201f 	nop
--   82f28:	d503201f 	nop
--   82f2c:	d503201f 	nop
--   82f30:	d503201f 	nop
--   82f34:	d503201f 	nop
--   82f38:	d503201f 	nop
--   82f3c:	d503201f 	nop
--   82f40:	d503201f 	nop
--   82f44:	d503201f 	nop
--   82f48:	d503201f 	nop
--   82f4c:	d503201f 	nop
--   82f50:	d503201f 	nop
--   82f54:	d503201f 	nop
--   82f58:	d503201f 	nop
--   82f5c:	d503201f 	nop
--   82f60:	d503201f 	nop
--   82f64:	d503201f 	nop
--   82f68:	d503201f 	nop
--   82f6c:	d503201f 	nop
--   82f70:	d503201f 	nop
--   82f74:	d503201f 	nop
--   82f78:	d503201f 	nop
--   82f7c:	d503201f 	nop
--	ventry	error_invalid_el0_32			// Error 32-bit EL0
--   82f80:	14000135 	b	83454 <error_invalid_el0_32>
--
--0000000000082f84 <sync_invalid_el1t>:
--
--sync_invalid_el1t:
--	handle_invalid_entry  SYNC_INVALID_EL1t
--   82f84:	d10443ff 	sub	sp, sp, #0x110
--   82f88:	a90007e0 	stp	x0, x1, [sp]
--   82f8c:	a9010fe2 	stp	x2, x3, [sp, #16]
--   82f90:	a90217e4 	stp	x4, x5, [sp, #32]
--   82f94:	a9031fe6 	stp	x6, x7, [sp, #48]
--   82f98:	a90427e8 	stp	x8, x9, [sp, #64]
--   82f9c:	a9052fea 	stp	x10, x11, [sp, #80]
--   82fa0:	a90637ec 	stp	x12, x13, [sp, #96]
--   82fa4:	a9073fee 	stp	x14, x15, [sp, #112]
--   82fa8:	a90847f0 	stp	x16, x17, [sp, #128]
--   82fac:	a9094ff2 	stp	x18, x19, [sp, #144]
--   82fb0:	a90a57f4 	stp	x20, x21, [sp, #160]
--   82fb4:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   82fb8:	a90c67f8 	stp	x24, x25, [sp, #192]
--   82fbc:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   82fc0:	a90e77fc 	stp	x28, x29, [sp, #224]
--   82fc4:	f9007bfe 	str	x30, [sp, #240]
--   82fc8:	d2800000 	mov	x0, #0x0                   	// #0
--   82fcc:	d5385201 	mrs	x1, esr_el1
--   82fd0:	d5384022 	mrs	x2, elr_el1
--   82fd4:	97fff920 	bl	81454 <show_invalid_entry_message>
--   82fd8:	1400015c 	b	83548 <err_hang>
--
--0000000000082fdc <irq_invalid_el1t>:
--
--irq_invalid_el1t:
--	handle_invalid_entry  IRQ_INVALID_EL1t
--   82fdc:	d10443ff 	sub	sp, sp, #0x110
--   82fe0:	a90007e0 	stp	x0, x1, [sp]
--   82fe4:	a9010fe2 	stp	x2, x3, [sp, #16]
--   82fe8:	a90217e4 	stp	x4, x5, [sp, #32]
--   82fec:	a9031fe6 	stp	x6, x7, [sp, #48]
--   82ff0:	a90427e8 	stp	x8, x9, [sp, #64]
--   82ff4:	a9052fea 	stp	x10, x11, [sp, #80]
--   82ff8:	a90637ec 	stp	x12, x13, [sp, #96]
--   82ffc:	a9073fee 	stp	x14, x15, [sp, #112]
--   83000:	a90847f0 	stp	x16, x17, [sp, #128]
--   83004:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83008:	a90a57f4 	stp	x20, x21, [sp, #160]
--   8300c:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83010:	a90c67f8 	stp	x24, x25, [sp, #192]
--   83014:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83018:	a90e77fc 	stp	x28, x29, [sp, #224]
--   8301c:	f9007bfe 	str	x30, [sp, #240]
--   83020:	d2800020 	mov	x0, #0x1                   	// #1
--   83024:	d5385201 	mrs	x1, esr_el1
--   83028:	d5384022 	mrs	x2, elr_el1
--   8302c:	97fff90a 	bl	81454 <show_invalid_entry_message>
--   83030:	14000146 	b	83548 <err_hang>
--
--0000000000083034 <fiq_invalid_el1t>:
--
--fiq_invalid_el1t:
--	handle_invalid_entry  FIQ_INVALID_EL1t
--   83034:	d10443ff 	sub	sp, sp, #0x110
--   83038:	a90007e0 	stp	x0, x1, [sp]
--   8303c:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83040:	a90217e4 	stp	x4, x5, [sp, #32]
--   83044:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83048:	a90427e8 	stp	x8, x9, [sp, #64]
--   8304c:	a9052fea 	stp	x10, x11, [sp, #80]
--   83050:	a90637ec 	stp	x12, x13, [sp, #96]
--   83054:	a9073fee 	stp	x14, x15, [sp, #112]
--   83058:	a90847f0 	stp	x16, x17, [sp, #128]
--   8305c:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83060:	a90a57f4 	stp	x20, x21, [sp, #160]
--   83064:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83068:	a90c67f8 	stp	x24, x25, [sp, #192]
--   8306c:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83070:	a90e77fc 	stp	x28, x29, [sp, #224]
--   83074:	f9007bfe 	str	x30, [sp, #240]
--   83078:	d2800040 	mov	x0, #0x2                   	// #2
--   8307c:	d5385201 	mrs	x1, esr_el1
--   83080:	d5384022 	mrs	x2, elr_el1
--   83084:	97fff8f4 	bl	81454 <show_invalid_entry_message>
--   83088:	14000130 	b	83548 <err_hang>
--
--000000000008308c <error_invalid_el1t>:
--
--error_invalid_el1t:
--	handle_invalid_entry  ERROR_INVALID_EL1t
--   8308c:	d10443ff 	sub	sp, sp, #0x110
--   83090:	a90007e0 	stp	x0, x1, [sp]
--   83094:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83098:	a90217e4 	stp	x4, x5, [sp, #32]
--   8309c:	a9031fe6 	stp	x6, x7, [sp, #48]
--   830a0:	a90427e8 	stp	x8, x9, [sp, #64]
--   830a4:	a9052fea 	stp	x10, x11, [sp, #80]
--   830a8:	a90637ec 	stp	x12, x13, [sp, #96]
--   830ac:	a9073fee 	stp	x14, x15, [sp, #112]
--   830b0:	a90847f0 	stp	x16, x17, [sp, #128]
--   830b4:	a9094ff2 	stp	x18, x19, [sp, #144]
--   830b8:	a90a57f4 	stp	x20, x21, [sp, #160]
--   830bc:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   830c0:	a90c67f8 	stp	x24, x25, [sp, #192]
--   830c4:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   830c8:	a90e77fc 	stp	x28, x29, [sp, #224]
--   830cc:	f9007bfe 	str	x30, [sp, #240]
--   830d0:	d2800060 	mov	x0, #0x3                   	// #3
--   830d4:	d5385201 	mrs	x1, esr_el1
--   830d8:	d5384022 	mrs	x2, elr_el1
--   830dc:	97fff8de 	bl	81454 <show_invalid_entry_message>
--   830e0:	1400011a 	b	83548 <err_hang>
--
--00000000000830e4 <sync_invalid_el1h>:
--
--sync_invalid_el1h:
--	handle_invalid_entry  SYNC_INVALID_EL1h
--   830e4:	d10443ff 	sub	sp, sp, #0x110
--   830e8:	a90007e0 	stp	x0, x1, [sp]
--   830ec:	a9010fe2 	stp	x2, x3, [sp, #16]
--   830f0:	a90217e4 	stp	x4, x5, [sp, #32]
--   830f4:	a9031fe6 	stp	x6, x7, [sp, #48]
--   830f8:	a90427e8 	stp	x8, x9, [sp, #64]
--   830fc:	a9052fea 	stp	x10, x11, [sp, #80]
--   83100:	a90637ec 	stp	x12, x13, [sp, #96]
--   83104:	a9073fee 	stp	x14, x15, [sp, #112]
--   83108:	a90847f0 	stp	x16, x17, [sp, #128]
--   8310c:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83110:	a90a57f4 	stp	x20, x21, [sp, #160]
--   83114:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83118:	a90c67f8 	stp	x24, x25, [sp, #192]
--   8311c:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83120:	a90e77fc 	stp	x28, x29, [sp, #224]
--   83124:	f9007bfe 	str	x30, [sp, #240]
--   83128:	d2800080 	mov	x0, #0x4                   	// #4
--   8312c:	d5385201 	mrs	x1, esr_el1
--   83130:	d5384022 	mrs	x2, elr_el1
--   83134:	97fff8c8 	bl	81454 <show_invalid_entry_message>
--   83138:	14000104 	b	83548 <err_hang>
--
--000000000008313c <fiq_invalid_el1h>:
--
--fiq_invalid_el1h:
--	handle_invalid_entry  FIQ_INVALID_EL1h
--   8313c:	d10443ff 	sub	sp, sp, #0x110
--   83140:	a90007e0 	stp	x0, x1, [sp]
--   83144:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83148:	a90217e4 	stp	x4, x5, [sp, #32]
--   8314c:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83150:	a90427e8 	stp	x8, x9, [sp, #64]
--   83154:	a9052fea 	stp	x10, x11, [sp, #80]
--   83158:	a90637ec 	stp	x12, x13, [sp, #96]
--   8315c:	a9073fee 	stp	x14, x15, [sp, #112]
--   83160:	a90847f0 	stp	x16, x17, [sp, #128]
--   83164:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83168:	a90a57f4 	stp	x20, x21, [sp, #160]
--   8316c:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83170:	a90c67f8 	stp	x24, x25, [sp, #192]
--   83174:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83178:	a90e77fc 	stp	x28, x29, [sp, #224]
--   8317c:	f9007bfe 	str	x30, [sp, #240]
--   83180:	d28000c0 	mov	x0, #0x6                   	// #6
--   83184:	d5385201 	mrs	x1, esr_el1
--   83188:	d5384022 	mrs	x2, elr_el1
--   8318c:	97fff8b2 	bl	81454 <show_invalid_entry_message>
--   83190:	140000ee 	b	83548 <err_hang>
--
--0000000000083194 <error_invalid_el1h>:
--
--error_invalid_el1h:
--	handle_invalid_entry  ERROR_INVALID_EL1h
--   83194:	d10443ff 	sub	sp, sp, #0x110
--   83198:	a90007e0 	stp	x0, x1, [sp]
--   8319c:	a9010fe2 	stp	x2, x3, [sp, #16]
--   831a0:	a90217e4 	stp	x4, x5, [sp, #32]
--   831a4:	a9031fe6 	stp	x6, x7, [sp, #48]
--   831a8:	a90427e8 	stp	x8, x9, [sp, #64]
--   831ac:	a9052fea 	stp	x10, x11, [sp, #80]
--   831b0:	a90637ec 	stp	x12, x13, [sp, #96]
--   831b4:	a9073fee 	stp	x14, x15, [sp, #112]
--   831b8:	a90847f0 	stp	x16, x17, [sp, #128]
--   831bc:	a9094ff2 	stp	x18, x19, [sp, #144]
--   831c0:	a90a57f4 	stp	x20, x21, [sp, #160]
--   831c4:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   831c8:	a90c67f8 	stp	x24, x25, [sp, #192]
--   831cc:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   831d0:	a90e77fc 	stp	x28, x29, [sp, #224]
--   831d4:	f9007bfe 	str	x30, [sp, #240]
--   831d8:	d28000e0 	mov	x0, #0x7                   	// #7
--   831dc:	d5385201 	mrs	x1, esr_el1
--   831e0:	d5384022 	mrs	x2, elr_el1
--   831e4:	97fff89c 	bl	81454 <show_invalid_entry_message>
--   831e8:	140000d8 	b	83548 <err_hang>
--
--00000000000831ec <sync_invalid_el0_64>:
--
--sync_invalid_el0_64:
--	handle_invalid_entry  SYNC_INVALID_EL0_64
--   831ec:	d10443ff 	sub	sp, sp, #0x110
--   831f0:	a90007e0 	stp	x0, x1, [sp]
--   831f4:	a9010fe2 	stp	x2, x3, [sp, #16]
--   831f8:	a90217e4 	stp	x4, x5, [sp, #32]
--   831fc:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83200:	a90427e8 	stp	x8, x9, [sp, #64]
--   83204:	a9052fea 	stp	x10, x11, [sp, #80]
--   83208:	a90637ec 	stp	x12, x13, [sp, #96]
--   8320c:	a9073fee 	stp	x14, x15, [sp, #112]
--   83210:	a90847f0 	stp	x16, x17, [sp, #128]
--   83214:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83218:	a90a57f4 	stp	x20, x21, [sp, #160]
--   8321c:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83220:	a90c67f8 	stp	x24, x25, [sp, #192]
--   83224:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83228:	a90e77fc 	stp	x28, x29, [sp, #224]
--   8322c:	f9007bfe 	str	x30, [sp, #240]
--   83230:	d2800100 	mov	x0, #0x8                   	// #8
--   83234:	d5385201 	mrs	x1, esr_el1
--   83238:	d5384022 	mrs	x2, elr_el1
--   8323c:	97fff886 	bl	81454 <show_invalid_entry_message>
--   83240:	140000c2 	b	83548 <err_hang>
--
--0000000000083244 <irq_invalid_el0_64>:
--
--irq_invalid_el0_64:
--	handle_invalid_entry  IRQ_INVALID_EL0_64
--   83244:	d10443ff 	sub	sp, sp, #0x110
--   83248:	a90007e0 	stp	x0, x1, [sp]
--   8324c:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83250:	a90217e4 	stp	x4, x5, [sp, #32]
--   83254:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83258:	a90427e8 	stp	x8, x9, [sp, #64]
--   8325c:	a9052fea 	stp	x10, x11, [sp, #80]
--   83260:	a90637ec 	stp	x12, x13, [sp, #96]
--   83264:	a9073fee 	stp	x14, x15, [sp, #112]
--   83268:	a90847f0 	stp	x16, x17, [sp, #128]
--   8326c:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83270:	a90a57f4 	stp	x20, x21, [sp, #160]
--   83274:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83278:	a90c67f8 	stp	x24, x25, [sp, #192]
--   8327c:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83280:	a90e77fc 	stp	x28, x29, [sp, #224]
--   83284:	f9007bfe 	str	x30, [sp, #240]
--   83288:	d2800120 	mov	x0, #0x9                   	// #9
--   8328c:	d5385201 	mrs	x1, esr_el1
--   83290:	d5384022 	mrs	x2, elr_el1
--   83294:	97fff870 	bl	81454 <show_invalid_entry_message>
--   83298:	140000ac 	b	83548 <err_hang>
--
--000000000008329c <fiq_invalid_el0_64>:
--
--fiq_invalid_el0_64:
--	handle_invalid_entry  FIQ_INVALID_EL0_64
--   8329c:	d10443ff 	sub	sp, sp, #0x110
--   832a0:	a90007e0 	stp	x0, x1, [sp]
--   832a4:	a9010fe2 	stp	x2, x3, [sp, #16]
--   832a8:	a90217e4 	stp	x4, x5, [sp, #32]
--   832ac:	a9031fe6 	stp	x6, x7, [sp, #48]
--   832b0:	a90427e8 	stp	x8, x9, [sp, #64]
--   832b4:	a9052fea 	stp	x10, x11, [sp, #80]
--   832b8:	a90637ec 	stp	x12, x13, [sp, #96]
--   832bc:	a9073fee 	stp	x14, x15, [sp, #112]
--   832c0:	a90847f0 	stp	x16, x17, [sp, #128]
--   832c4:	a9094ff2 	stp	x18, x19, [sp, #144]
--   832c8:	a90a57f4 	stp	x20, x21, [sp, #160]
--   832cc:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   832d0:	a90c67f8 	stp	x24, x25, [sp, #192]
--   832d4:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   832d8:	a90e77fc 	stp	x28, x29, [sp, #224]
--   832dc:	f9007bfe 	str	x30, [sp, #240]
--   832e0:	d2800140 	mov	x0, #0xa                   	// #10
--   832e4:	d5385201 	mrs	x1, esr_el1
--   832e8:	d5384022 	mrs	x2, elr_el1
--   832ec:	97fff85a 	bl	81454 <show_invalid_entry_message>
--   832f0:	14000096 	b	83548 <err_hang>
--
--00000000000832f4 <error_invalid_el0_64>:
--
--error_invalid_el0_64:
--	handle_invalid_entry  ERROR_INVALID_EL0_64
--   832f4:	d10443ff 	sub	sp, sp, #0x110
--   832f8:	a90007e0 	stp	x0, x1, [sp]
--   832fc:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83300:	a90217e4 	stp	x4, x5, [sp, #32]
--   83304:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83308:	a90427e8 	stp	x8, x9, [sp, #64]
--   8330c:	a9052fea 	stp	x10, x11, [sp, #80]
--   83310:	a90637ec 	stp	x12, x13, [sp, #96]
--   83314:	a9073fee 	stp	x14, x15, [sp, #112]
--   83318:	a90847f0 	stp	x16, x17, [sp, #128]
--   8331c:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83320:	a90a57f4 	stp	x20, x21, [sp, #160]
--   83324:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83328:	a90c67f8 	stp	x24, x25, [sp, #192]
--   8332c:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83330:	a90e77fc 	stp	x28, x29, [sp, #224]
--   83334:	f9007bfe 	str	x30, [sp, #240]
--   83338:	d2800160 	mov	x0, #0xb                   	// #11
--   8333c:	d5385201 	mrs	x1, esr_el1
--   83340:	d5384022 	mrs	x2, elr_el1
--   83344:	97fff844 	bl	81454 <show_invalid_entry_message>
--   83348:	14000080 	b	83548 <err_hang>
--
--000000000008334c <sync_invalid_el0_32>:
--
--sync_invalid_el0_32:
--	handle_invalid_entry  SYNC_INVALID_EL0_32
--   8334c:	d10443ff 	sub	sp, sp, #0x110
--   83350:	a90007e0 	stp	x0, x1, [sp]
--   83354:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83358:	a90217e4 	stp	x4, x5, [sp, #32]
--   8335c:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83360:	a90427e8 	stp	x8, x9, [sp, #64]
--   83364:	a9052fea 	stp	x10, x11, [sp, #80]
--   83368:	a90637ec 	stp	x12, x13, [sp, #96]
--   8336c:	a9073fee 	stp	x14, x15, [sp, #112]
--   83370:	a90847f0 	stp	x16, x17, [sp, #128]
--   83374:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83378:	a90a57f4 	stp	x20, x21, [sp, #160]
--   8337c:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83380:	a90c67f8 	stp	x24, x25, [sp, #192]
--   83384:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83388:	a90e77fc 	stp	x28, x29, [sp, #224]
--   8338c:	f9007bfe 	str	x30, [sp, #240]
--   83390:	d2800180 	mov	x0, #0xc                   	// #12
--   83394:	d5385201 	mrs	x1, esr_el1
--   83398:	d5384022 	mrs	x2, elr_el1
--   8339c:	97fff82e 	bl	81454 <show_invalid_entry_message>
--   833a0:	1400006a 	b	83548 <err_hang>
--
--00000000000833a4 <irq_invalid_el0_32>:
--
--irq_invalid_el0_32:
--	handle_invalid_entry  IRQ_INVALID_EL0_32
--   833a4:	d10443ff 	sub	sp, sp, #0x110
--   833a8:	a90007e0 	stp	x0, x1, [sp]
--   833ac:	a9010fe2 	stp	x2, x3, [sp, #16]
--   833b0:	a90217e4 	stp	x4, x5, [sp, #32]
--   833b4:	a9031fe6 	stp	x6, x7, [sp, #48]
--   833b8:	a90427e8 	stp	x8, x9, [sp, #64]
--   833bc:	a9052fea 	stp	x10, x11, [sp, #80]
--   833c0:	a90637ec 	stp	x12, x13, [sp, #96]
--   833c4:	a9073fee 	stp	x14, x15, [sp, #112]
--   833c8:	a90847f0 	stp	x16, x17, [sp, #128]
--   833cc:	a9094ff2 	stp	x18, x19, [sp, #144]
--   833d0:	a90a57f4 	stp	x20, x21, [sp, #160]
--   833d4:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   833d8:	a90c67f8 	stp	x24, x25, [sp, #192]
--   833dc:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   833e0:	a90e77fc 	stp	x28, x29, [sp, #224]
--   833e4:	f9007bfe 	str	x30, [sp, #240]
--   833e8:	d28001a0 	mov	x0, #0xd                   	// #13
--   833ec:	d5385201 	mrs	x1, esr_el1
--   833f0:	d5384022 	mrs	x2, elr_el1
--   833f4:	97fff818 	bl	81454 <show_invalid_entry_message>
--   833f8:	14000054 	b	83548 <err_hang>
--
--00000000000833fc <fiq_invalid_el0_32>:
--
--fiq_invalid_el0_32:
--	handle_invalid_entry  FIQ_INVALID_EL0_32
--   833fc:	d10443ff 	sub	sp, sp, #0x110
--   83400:	a90007e0 	stp	x0, x1, [sp]
--   83404:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83408:	a90217e4 	stp	x4, x5, [sp, #32]
--   8340c:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83410:	a90427e8 	stp	x8, x9, [sp, #64]
--   83414:	a9052fea 	stp	x10, x11, [sp, #80]
--   83418:	a90637ec 	stp	x12, x13, [sp, #96]
--   8341c:	a9073fee 	stp	x14, x15, [sp, #112]
--   83420:	a90847f0 	stp	x16, x17, [sp, #128]
--   83424:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83428:	a90a57f4 	stp	x20, x21, [sp, #160]
--   8342c:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83430:	a90c67f8 	stp	x24, x25, [sp, #192]
--   83434:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83438:	a90e77fc 	stp	x28, x29, [sp, #224]
--   8343c:	f9007bfe 	str	x30, [sp, #240]
--   83440:	d28001c0 	mov	x0, #0xe                   	// #14
--   83444:	d5385201 	mrs	x1, esr_el1
--   83448:	d5384022 	mrs	x2, elr_el1
--   8344c:	97fff802 	bl	81454 <show_invalid_entry_message>
--   83450:	1400003e 	b	83548 <err_hang>
--
--0000000000083454 <error_invalid_el0_32>:
--
--error_invalid_el0_32:
--	handle_invalid_entry  ERROR_INVALID_EL0_32
--   83454:	d10443ff 	sub	sp, sp, #0x110
--   83458:	a90007e0 	stp	x0, x1, [sp]
--   8345c:	a9010fe2 	stp	x2, x3, [sp, #16]
--   83460:	a90217e4 	stp	x4, x5, [sp, #32]
--   83464:	a9031fe6 	stp	x6, x7, [sp, #48]
--   83468:	a90427e8 	stp	x8, x9, [sp, #64]
--   8346c:	a9052fea 	stp	x10, x11, [sp, #80]
--   83470:	a90637ec 	stp	x12, x13, [sp, #96]
--   83474:	a9073fee 	stp	x14, x15, [sp, #112]
--   83478:	a90847f0 	stp	x16, x17, [sp, #128]
--   8347c:	a9094ff2 	stp	x18, x19, [sp, #144]
--   83480:	a90a57f4 	stp	x20, x21, [sp, #160]
--   83484:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   83488:	a90c67f8 	stp	x24, x25, [sp, #192]
--   8348c:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   83490:	a90e77fc 	stp	x28, x29, [sp, #224]
--   83494:	f9007bfe 	str	x30, [sp, #240]
--   83498:	d28001e0 	mov	x0, #0xf                   	// #15
--   8349c:	d5385201 	mrs	x1, esr_el1
--   834a0:	d5384022 	mrs	x2, elr_el1
--   834a4:	97fff7ec 	bl	81454 <show_invalid_entry_message>
--   834a8:	14000028 	b	83548 <err_hang>
--
--00000000000834ac <el1_irq>:
--
--el1_irq:
--	kernel_entry 
--   834ac:	d10443ff 	sub	sp, sp, #0x110
--   834b0:	a90007e0 	stp	x0, x1, [sp]
--   834b4:	a9010fe2 	stp	x2, x3, [sp, #16]
--   834b8:	a90217e4 	stp	x4, x5, [sp, #32]
--   834bc:	a9031fe6 	stp	x6, x7, [sp, #48]
--   834c0:	a90427e8 	stp	x8, x9, [sp, #64]
--   834c4:	a9052fea 	stp	x10, x11, [sp, #80]
--   834c8:	a90637ec 	stp	x12, x13, [sp, #96]
--   834cc:	a9073fee 	stp	x14, x15, [sp, #112]
--   834d0:	a90847f0 	stp	x16, x17, [sp, #128]
--   834d4:	a9094ff2 	stp	x18, x19, [sp, #144]
--   834d8:	a90a57f4 	stp	x20, x21, [sp, #160]
--   834dc:	a90b5ff6 	stp	x22, x23, [sp, #176]
--   834e0:	a90c67f8 	stp	x24, x25, [sp, #192]
--   834e4:	a90d6ffa 	stp	x26, x27, [sp, #208]
--   834e8:	a90e77fc 	stp	x28, x29, [sp, #224]
--   834ec:	f9007bfe 	str	x30, [sp, #240]
--	bl	handle_irq
--   834f0:	97fff7c6 	bl	81408 <handle_irq>
--	kernel_exit 
--   834f4:	a94007e0 	ldp	x0, x1, [sp]
--   834f8:	a9410fe2 	ldp	x2, x3, [sp, #16]
--   834fc:	a94217e4 	ldp	x4, x5, [sp, #32]
--   83500:	a9431fe6 	ldp	x6, x7, [sp, #48]
--   83504:	a94427e8 	ldp	x8, x9, [sp, #64]
--   83508:	a9452fea 	ldp	x10, x11, [sp, #80]
--   8350c:	a94637ec 	ldp	x12, x13, [sp, #96]
--   83510:	a9473fee 	ldp	x14, x15, [sp, #112]
--   83514:	a94847f0 	ldp	x16, x17, [sp, #128]
--   83518:	a9494ff2 	ldp	x18, x19, [sp, #144]
--   8351c:	a94a57f4 	ldp	x20, x21, [sp, #160]
--   83520:	a94b5ff6 	ldp	x22, x23, [sp, #176]
--   83524:	a94c67f8 	ldp	x24, x25, [sp, #192]
--   83528:	a94d6ffa 	ldp	x26, x27, [sp, #208]
--   8352c:	a94e77fc 	ldp	x28, x29, [sp, #224]
--   83530:	f9407bfe 	ldr	x30, [sp, #240]
--   83534:	910443ff 	add	sp, sp, #0x110
--   83538:	d69f03e0 	eret
--
--000000000008353c <ret_from_fork>:
--
--.globl ret_from_fork
--ret_from_fork:
--	bl	schedule_tail
--   8353c:	97fff8e6 	bl	818d4 <schedule_tail>
--	mov	x0, x20
--   83540:	aa1403e0 	mov	x0, x20
--	blr	x19 		//should never return
--   83544:	d63f0260 	blr	x19
--
--0000000000083548 <err_hang>:
--
--.globl err_hang
--err_hang: b err_hang
--   83548:	14000000 	b	83548 <err_hang>
--
--000000000008354c <irq_vector_init>:
--.globl irq_vector_init
--irq_vector_init:
--	adr	x0, vectors		// load VBAR_EL1 with virtual
--   8354c:	10ff95a0 	adr	x0, 82800 <vectors>
--	msr	vbar_el1, x0		// vector table address
--   83550:	d518c000 	msr	vbar_el1, x0
--	ret
--   83554:	d65f03c0 	ret
--
--0000000000083558 <enable_irq>:
--
--.globl enable_irq
--enable_irq:
--	msr daifclr, #2
--   83558:	d50342ff 	msr	daifclr, #0x2
--	ret
--   8355c:	d65f03c0 	ret
--
--0000000000083560 <disable_irq>:
--
--.globl disable_irq
--disable_irq:
--	msr	daifset, #0xf
--   83560:	d5034fdf 	msr	daifset, #0xf
--	ret
--   83564:	d65f03c0 	ret
--
--0000000000083568 <memzero>:
--.globl memzero
--memzero:
--	str xzr, [x0], #8
--   83568:	f800841f 	str	xzr, [x0], #8
--	subs x1, x1, #8
--   8356c:	f1002021 	subs	x1, x1, #0x8
--	b.gt memzero
--   83570:	54ffffcc 	b.gt	83568 <memzero>
--	ret
--   83574:	d65f03c0 	ret
--
--0000000000083578 <cpu_switch_to>:
--
--/* this is where context switch happens */
--
--.globl cpu_switch_to
--cpu_switch_to:
--	mov	x10, #THREAD_CPU_CONTEXT
--   83578:	d280000a 	mov	x10, #0x0                   	// #0
--	add	x8, x0, x10
--   8357c:	8b0a0008 	add	x8, x0, x10
--	mov	x9, sp
--   83580:	910003e9 	mov	x9, sp
--	stp	x19, x20, [x8], #16		// store callee-saved registers
--   83584:	a8815113 	stp	x19, x20, [x8], #16
--	stp	x21, x22, [x8], #16
--   83588:	a8815915 	stp	x21, x22, [x8], #16
--	stp	x23, x24, [x8], #16
--   8358c:	a8816117 	stp	x23, x24, [x8], #16
--	stp	x25, x26, [x8], #16
--   83590:	a8816919 	stp	x25, x26, [x8], #16
--	stp	x27, x28, [x8], #16
--   83594:	a881711b 	stp	x27, x28, [x8], #16
--	stp	x29, x9, [x8], #16
--   83598:	a881251d 	stp	x29, x9, [x8], #16
--	str	x30, [x8]				// save LR (x30), pointing to where this function is called from
--   8359c:	f900011e 	str	x30, [x8]
--	add	x8, x1, x10
--   835a0:	8b0a0028 	add	x8, x1, x10
--	ldp	x19, x20, [x8], #16		// restore callee-saved registers
--   835a4:	a8c15113 	ldp	x19, x20, [x8], #16
--	ldp	x21, x22, [x8], #16
--   835a8:	a8c15915 	ldp	x21, x22, [x8], #16
--	ldp	x23, x24, [x8], #16
--   835ac:	a8c16117 	ldp	x23, x24, [x8], #16
--	ldp	x25, x26, [x8], #16
--   835b0:	a8c16919 	ldp	x25, x26, [x8], #16
--	ldp	x27, x28, [x8], #16
--   835b4:	a8c1711b 	ldp	x27, x28, [x8], #16
--	ldp	x29, x9, [x8], #16
--   835b8:	a8c1251d 	ldp	x29, x9, [x8], #16
--	ldr	x30, [x8]				// x30 == LR
--   835bc:	f940011e 	ldr	x30, [x8]
--	mov	sp, x9
--   835c0:	9100013f 	mov	sp, x9
--	ret							// jump to where LR points to 
--   835c4:	d65f03c0 	ret
--
--00000000000835c8 <get_el>:
--.globl get_el
--get_el:
--	mrs x0, CurrentEL
--   835c8:	d5384240 	mrs	x0, currentel
--	lsr x0, x0, #2
--   835cc:	d342fc00 	lsr	x0, x0, #2
--	ret
--   835d0:	d65f03c0 	ret
--
--00000000000835d4 <put32>:
--
--.globl put32
--put32:
--	str w1,[x0]
--   835d4:	b9000001 	str	w1, [x0]
--	ret
--   835d8:	d65f03c0 	ret
--
--00000000000835dc <get32>:
--
--.globl get32
--get32:
--	ldr w0,[x0]
--   835dc:	b9400000 	ldr	w0, [x0]
--	ret
--   835e0:	d65f03c0 	ret
--
--00000000000835e4 <delay>:
--
--.globl delay
--delay:
--	subs x0, x0, #1
--   835e4:	f1000400 	subs	x0, x0, #0x1
--	bne delay
--   835e8:	54ffffe1 	b.ne	835e4 <delay>  // b.any
--	ret
--   835ec:	d65f03c0 	ret
-diff --git a/src/exp4a/src/fork.c b/src/exp4a/src/fork.c
-index a94f7b5..059c16c 100644
---- a/src/exp4a/src/fork.c
-+++ b/src/exp4a/src/fork.c
-@@ -14,7 +14,7 @@ int copy_process(unsigned long fn, unsigned long arg)
- 	p->state = TASK_RUNNING;
- 	p->counter = p->priority;
- //	p->preempt_count = 1; //disable preemtion until schedule_tail
--	p->delay_sec = 0;
-+
- 	p->cpu_context.x19 = fn;
- 	p->cpu_context.x20 = arg;
- 	p->cpu_context.pc = (unsigned long)ret_from_fork;
-diff --git a/src/exp4a/src/irq.S b/src/exp4a/src/irq.S
-deleted file mode 100644
-index 766e861..0000000
---- a/src/exp4a/src/irq.S
-+++ /dev/null
-@@ -1,15 +0,0 @@
--.globl irq_vector_init
--irq_vector_init:
--	adr	x0, vectors		// load VBAR_EL1 with virtual
--	msr	vbar_el1, x0		// vector table address
--	ret
--
--.globl enable_irq
--enable_irq:
--	msr daifclr, #2
--	ret
--
--.globl disable_irq
--disable_irq:
--	msr	daifset, #0xf
--	ret
-diff --git a/src/exp4a/src/irq.c b/src/exp4a/src/irq.c
-index 67040f7..6469a8b 100644
---- a/src/exp4a/src/irq.c
-+++ b/src/exp4a/src/irq.c
-@@ -26,26 +26,20 @@ const char *entry_error_messages[] = {
-     "ERROR_INVALID_EL0_32"	
- };
- 
--void enable_interrupt_controller()
--{
-+//void enable_interrupt_controller()
-+//{
- //    // Enables Core 0 Timers interrupt control for the generic timer
--    put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
--}
--
-+//    put32(TIMER_INT_CTRL_0, TIMER_INT_CTRL_0_VALUE);
-+//}
-+//
- 
- void handle_irq(void)
- {
-     // Each Core has its own pending local intrrupts register
-     unsigned int irq = get32(INT_SOURCE_0);
--    switch (irq) {
--        case (GENERIC_TIMER_INTERRUPT):
--        	handle_generic_timer_irq();
--        	break;
--	default:
--		printf("We do not expect pending irq to happen: %x\r\n", irq);
--	//while (1)
--	//	;
--    }
-+	printf("We do not expect pending irq to happen: %x\r\n", irq);
-+	while (1)
-+		;
- }
- 
- void show_invalid_entry_message(int type, unsigned long esr, unsigned long address)
-diff --git a/src/exp4a/src/kernel.c b/src/exp4a/src/kernel.c
-index d0c8142..910effe 100644
---- a/src/exp4a/src/kernel.c
-+++ b/src/exp4a/src/kernel.c
-@@ -16,13 +16,6 @@
- #define CHAR_DELAY (1000000)
- #endif
- 
--void sleep(int x)
--{
--        current->delay_sec = x;
--        current->state = TASK_WAITING;
--        schedule();
--}
--
- void process(char *array)
- {
- #ifdef USE_LFB // (optional) determine the init locations on the graphical console
-@@ -47,10 +40,6 @@ void process(char *array)
- #endif
- 			delay(CHAR_DELAY);
- 		} 
--		if (array[0] == 'a')
--			sleep(3);
--		else if (array[0] == '1')
--			sleep(5);
- 		schedule(); // yield
- 	}
- }
-@@ -60,12 +49,7 @@ void kernel_main(void)
- 	uart_init();
- 	init_printf(0, putc);
- 
--	printf("kernel boots\r\n");
--
--	irq_vector_init();
--	generic_timer_init();
--	enable_interrupt_controller();
--	enable_irq();
-+	printf("kernel boots\r\n");	
- 
- #ifdef USE_LFB // (optional) init output to the graphical console
- 	lfb_init(); 
-diff --git a/src/exp4a/src/sched.c b/src/exp4a/src/sched.c
-index ae49c85..1ea9911 100644
---- a/src/exp4a/src/sched.c
-+++ b/src/exp4a/src/sched.c
-@@ -1,4 +1,3 @@
--
- #include "sched.h"
- #include "irq.h"
- #include "printf.h"
-@@ -7,7 +6,6 @@ static struct task_struct init_task = INIT_TASK;
- struct task_struct *current = &(init_task);
- struct task_struct * task[NR_TASKS] = {&(init_task), };
- int nr_tasks = 1;
--//int delay_sec = 0;
- 
- void _schedule(void)
- {
-@@ -16,7 +14,7 @@ void _schedule(void)
- 	while (1) {
- 		c = -1;	// the maximum counter found so far
- 		next = 0;
--		//delay_sec = 0;
-+
- 		/* Iterates over all tasks and tries to find a task in 
- 		TASK_RUNNING state with the maximum counter. If such 
- 		a task is found, we immediately break from the while loop 
-@@ -28,16 +26,8 @@ void _schedule(void)
- 				c = p->counter;
- 				next = i;
- 			}
--//			if (p && p->state == TASK_WAITING) {
--//				p->delay_sec = p->delay_sec -1;
--//				if(p->delay_sec <= 0){
--  //                              	p->state = TASK_RUNNING;
--   //                             	c = p->counter;
--   //                             	next = i;
--//				}
--//			}
- 		}
--		if (c){
-+		if (c) {
- 			break;
- 		}
- 
-@@ -75,3 +65,4 @@ void switch_to(struct task_struct * next)
- void schedule_tail(void) {
- 	/* nothing */
- }
-+
-diff --git a/src/exp4a/src/sched.c.save b/src/exp4a/src/sched.c.save
-deleted file mode 100644
-index f004f89..0000000
---- a/src/exp4a/src/sched.c.save
-+++ /dev/null
-@@ -1,81 +0,0 @@
--#include "sched.h"
--#include "irq.h"
--#include "printf.h"
--
--static struct task_struct init_task = INIT_TASK;
--struct task_struct *current = &(init_task);
--struct task_struct * task[NR_TASKS] = {&(init_task), };
--int nr_tasks = 1;
--
--void _schedule(void)
--{
--	int next, c;
--	struct task_struct * p;
--	while (1) {
--		c = -1;	// the maximum counter found so far
--		next = 0;
--
--		/* Iterates over all tasks and tries to find a task in 
--		TASK_RUNNING state with the maximum counter. If such 
--		a task is found, we immediately break from the while loop 
--		and switch to this task. */
--
--		for (int i = 0; i < NR_TASKS; i++){
--			p = task[i];
--			if (p && p->state == TASK_RUNNING && p->counter > c) {
--				c = p->counter;
--				next = i;
--			}
--			if (p->state == TASK_WAITING) {
--				p->delay_sec = p->delay_sec-1;
--			}
--		}
--		if (p && p->state == TASK_WAITING) {
--			
--			if(p->delay_sec <= 0){
--				p->state = TASK_RUNNING;
--				c = p->counter;
--				next = i;
--		}
--
--		/* If no such task is found, this is either because i) no 
--		task is in TASK_RUNNING state or ii) all such tasks have 0 counters.
--		in our current implemenation which misses TASK_WAIT, only condition ii) is possible. 
--		Hence, we recharge counters. Bump counters for all tasks once. */
--		for (int i = 0; i < NR_TASKS; i++) {
--			p = task[i];
--			if (p) {
--				p->counter = (p->counter >> 1) + p->priority; // The increment depends on a task's priority.
--			}
--		}
--
--		/* loops back to pick the next task */
--	}
--	switch_to(task[next]);
--}
--
--void schedule(void)
--{
--	current->counter = 0;
--	_schedule();
--}
--
--void switch_to(struct task_struct * next) 
--{
--	if (current == next) 
--		return;
--	struct task_struct * prev = current;
--	current = next;
--	cpu_switch_to(prev, next);
--}
--
--void schedule_tail(void) {
--	/* nothing */
--}
--
--void sleep(int x)
--{
--	current->delay_sec = x;
--	current->state = TASK_WAITING;
--	schedule();
--}
-diff --git a/src/exp4a/src/timer.S b/src/exp4a/src/timer.S
-deleted file mode 100644
-index aade5f5..0000000
---- a/src/exp4a/src/timer.S
-+++ /dev/null
-@@ -1,20 +0,0 @@
--/** Here, the physical timer at EL1 is used with the TimerValue views.
-- *  Once the count-down has reach 0, the interrupt line is HIGH until
-- *  a new timer value > 0 is write into the CNTP_TVAL_EL0 system register.
-- *
-- *  See AArch64-referenc-manual p.2326 at
-- *  https://developer.arm.com/docs/ddi0487/ca/arm-architecture-reference-manual-armv8-for-armv8-a-architecture-profile
-- */
--
--.globl gen_timer_init
--gen_timer_init:
--	mov x0, #1
--	msr CNTP_CTL_EL0, x0
--	ret
--
--.globl gen_timer_reset
--gen_timer_reset:
--#    mov x0, #1
--#	lsl x0, x0, #24
--	msr CNTP_TVAL_EL0, x0
--    ret
-diff --git a/src/exp4a/src/timer.c b/src/exp4a/src/timer.c
-deleted file mode 100644
-index 0d4ad86..0000000
---- a/src/exp4a/src/timer.c
-+++ /dev/null
-@@ -1,79 +0,0 @@
--#include "utils.h"
--#include "printf.h"
--#include "peripherals/timer.h"
--#include "timer.h"
--#include "sched.h"
--
--#ifdef USE_QEMU
--//unsigned int interval = (1 << 26); // xzl: around 1 sec
--unsigned int interval = (1 << 26); // xzl: around 3 sec
--#else
--//unsigned int interval = 1 * 1000 * 1000; // xzl: around 1 sec
--unsigned int interval = 1 * 1000 * 1000; // xzl: around 3 sec
--#endif
--
--/* 	These are for Arm generic timer. 
--	They are fully functional on both QEMU and Rpi3 
--	Recommended.
--*/
--
--// xzl: CNTFRQ_EL0 reports the frequency of the system count
--static unsigned int read_cntfrq(void)
--{
--	unsigned int val;
--	asm volatile ("mrs %0, cntfrq_el0" : "=r" (val));
--  	return val;
--}
--
--void generic_timer_init ( void )
--{
--	unsigned int freq  = read_cntfrq();
--	printf("System count freq (CNTFRQ) is: %u\n", freq);
--
--	printf("interval is set to: %u\n", interval);
--	gen_timer_init();
--	gen_timer_reset(interval);
--}
--
--extern struct task_struct * task[64];
--void handle_generic_timer_irq( void ) 
--{
--	printf("Timer interrupt received. next in %u ticks\n\r", interval);
--	gen_timer_reset(interval);
--	for (int i=1; i<10; i++){
--		//task_struct p = task[i];
--		if (task[i] && task[i]->delay_sec > 0) {
--			task[i]->delay_sec = task[i]->delay_sec -1;
--		}
--		if (task[i]->delay_sec <= 0){
--			task[i]->state = 0;
--		}
--	}
--}
--
--
--/* 
--	These are for "System Timer". They are NOT in use by this project. 
--	I leave the code here FYI. 
--	Rpi3: System Timer works fine. Can generate intrerrupts and be used as a counter for timekeeping.
--	QEMU: System Timer can be used for timekeeping. Cannot generate interrupts. 
--		You may want to adjust @interval as needed
--	cf: 
--	https://fxlin.github.io/p1-kernel/exp3/rpi-os/#fyi-other-timers-on-rpi3
--*/
--unsigned int curVal = 0;
--
--void timer_init ( void )
--{
--	curVal = get32(TIMER_CLO);
--	curVal += interval;
--	put32(TIMER_C1, curVal);
--}
--
--void handle_timer_irq( void ) 
--{
--	curVal += interval;
--	put32(TIMER_C1, curVal);
--	put32(TIMER_CS, TIMER_CS_M1);
--	printf("Timer interrupt received\n\r");
--}
-diff --git a/src/exp4a/test.log b/src/exp4a/test.log
-deleted file mode 100644
-index e24f0d0..0000000
---- a/src/exp4a/test.log
-+++ /dev/null
-@@ -1,43 +0,0 @@
--Exception return from AArch64 EL2 to AArch64 EL1 PC 0x80038
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x81800
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x81800
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x81840
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x81840
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x81840
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x81840
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x8177c
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x8177c
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x8184c
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x8184c
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x817e0
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x817e0
--Taking exception 5 [IRQ]
--...from EL1 to EL1
--...with ESR 0x0/0x0
--...with ELR 0x81800
--...to EL1 PC 0x82a80 PSTATE 0x3c5
--Exception return from AArch64 EL1 to AArch64 EL1 PC 0x81800
